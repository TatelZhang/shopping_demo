{
    "success": true,
    "data": [{
        "id": "592917b59e32cc84569a7458",
        "author_id": "54009f5ccd66f2eb37190485",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><p>本来提供开发api，目的是为了开发第三方应用或客户端，如果大家用来学习也是好的，但现在很多人太过分了，随意发帖，at，严重影响了社区的用户，故而决定开始严查</p>\n<p>以下情况，直接封号</p>\n<ul>\n<li>测试标题</li>\n<li>无任何内容</li>\n<li>无意义回复</li>\n<li>测试帖，5分钟内没有删除</li>\n</ul>\n<p>欢迎大家监督</p>\n<p>封号</p>\n<ul>\n<li><a href=\"https://cnodejs.org/user/Mwangzhi\">https://cnodejs.org/user/Mwangzhi</a></li>\n<li><a href=\"https://cnodejs.org/user/lw6395\">https://cnodejs.org/user/lw6395</a></li>\n<li><a href=\"https://cnodejs.org/user/shengliang74\">https://cnodejs.org/user/shengliang74</a>  竟然挑衅，发帖说你来打我呀。。。。</li>\n<li><a href=\"https://cnodejs.org/user/h5-17\">https://cnodejs.org/user/h5-17</a> <a href=\"/user/h5-17\">@h5-17</a></li>\n<li><a href=\"https://cnodejs.org/user/592php\">https://cnodejs.org/user/592php</a> <a href=\"/user/592php\">@592php</a></li>\n</ul>\n<hr>\n<p>20170601更新</p>\n<p><a href=\"https://cnodejs.org/?tab=dev\">https://cnodejs.org/?tab=dev</a>  目前开了一个『客户端测试』专区，以后开发新客户端的同学，帖子直接发到这个专区去。tab 的值是 dev。</p>\n<p><img src=\"//dn-cnode.qbox.me/FundjyBuYk60yqQ-PdKstrPKY-7-\" alt=\"image.png\"></p>\n</div>",
        "title": "测试请发到客户端测试专区，违规影响用户的，直接封号",
        "last_reply_at": "2017-11-12T07:44:45.609Z",
        "good": false,
        "top": true,
        "reply_count": 127,
        "visit_count": 27199,
        "create_at": "2017-05-27T06:07:49.278Z",
        "author": {
            "loginname": "i5ting",
            "avatar_url": "https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"
        }
    }, {
        "id": "58eee565a92d341e48cfe7fc",
        "author_id": "54009f5ccd66f2eb37190485",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><h1>2017，我们来聊聊 Node.js</h1>\n<h2>版本帝？</h2>\n<p>Chrome浏览器已经蹦到57版本了，是名副其实的版本帝，作为兄弟的Node.js也一样，1.0之前等了6年，而从1.0到8.0，只用了2年时间，这世界到底怎么了？</p>\n<p>我们就数一下</p>\n<ul>\n<li>从v0.1到0.12用了6年</li>\n<li>2015-01-14发布了v1.0.0版本（io.js）</li>\n<li>2.x（io.js）</li>\n<li>3.x（io.js）</li>\n<li>2015年09月Node.js基金会已发布Node.js V4.0版 与io.js合并后的第一个版本</li>\n<li>2015年10月Node.jsv4.2.0将是首个lts长期支持版本</li>\n<li>2016年底发布到4.2.4 &amp;&amp; 5.4.0</li>\n<li>2016年3月20日v4.4.0 LTS（长期支持版本）和v5.9.0 Stable（稳定版本）</li>\n<li>2016 年底 v6.0 支持95%以上的es6特性 ， v7.0通过flag支持async函数，99%的es6特性</li>\n<li>2017年2月发布v7.6版本，可以不通过flag使用async函数</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/Fv8fvViUeOJpBlOWYzBo1txRUhdN\" alt=\"lts-schedule.png\"></p>\n<p>整体来说趋于稳定</p>\n<ul>\n<li>成立了Node.js基金会，能够让Node.js在未来有更好的开源社区支持</li>\n<li>发布了LTS版本，意味着api稳定</li>\n<li>快速发版本，很多人吐槽这个，其实换个角度看，这也是社区活跃的一个体现，但如果大家真的看CHANGELOG，其实都是小改进，而且是边边角角的改进，也就是说Node.js的core（核心）已经非常稳定了，可以大规模使用</li>\n</ul>\n<h2>已无性能优势？</h2>\n<p>Node.js在2009年横空出世，可以说是纯异步获得高性能的功劳。所有语言几乎没有能够和它相比的，比如Java、PHP、Ruby都被啪啪的打脸。但是山一程，水一程，福祸相依，因为性能太出众，导致很多语言、编程模型上有更多探索，比如go语言产生、php里的swolo和vm改进等，大家似乎都以不支持异步为耻辱。后来的故事大家都知道了，性能都提到非常高，c10问题已经没人再考虑，只是大家实现早晚而产生的性能差距而已。</p>\n<blockquote>\n<p>编程语言的性能趋于一样的极限，所以剩下的选择，只有喜好</p>\n</blockquote>\n<p>那么在这种情况下，Node.js还有优势么？</p>\n<ul>\n<li>实现成本：Node.js除了异步流程控制稍复杂外，其他的都非常简单，比如写法，你可以面向过程、面向对象、函数式，根据自己的解决选择就好了。不要因为它现在变化快，就觉得自己跟不上潮流。尤其是后端程序员转Node.js几乎是2周以内的成本，某些语言光熟悉语法习惯也不止2周吧？</li>\n<li>调优成本：Node.js即使不优化，它的性能也非常好，如果优化，也比其他语言更简单</li>\n<li>学习成本：是否必须用，如果是必须要用，那就少学一样是一样，人生有限，不能都花在写hello world上。我想问，大前端离得开js么？</li>\n</ul>\n<blockquote>\n<p>误读：Node.js已无性能优势，它现在最强大的是基于npm的生态</p>\n</blockquote>\n<p>上面是成本上的比较，其实大家把关注点都转移到基于npm的生态上，截止2017年2月，在npm上有超过45万个模块，秒杀无数。npm是所有的开源的包管理里最强大的，我们说更了不起的Node.js，其实npm居功甚伟，后面会有独立的章节进行阐述。</p>\n<p>来自<a href=\"http://www.modulecounts.com/\">www.modulecounts.com</a>的各个包管理模块梳理的比较</p>\n<p><img src=\"//dn-cnode.qbox.me/FjmazMxffKETUdl9-NVoSqLB-DyT\" alt=\"Screen Shot 2017-04-04 at 21.02.41.png\">\nnpm生态是Node的优势不假，可是说“Node.js没有性能优势”真的对么？这其实就是误读，Node.js的性能依然很好呀，而且它有npm极其强大的生态，可谓性能与生态双剑合璧，你说你死不死？</p>\n<h2>异步和回调地狱？</h2>\n<blockquote>\n<p>天生异步，败也异步，成也异步</p>\n</blockquote>\n<p>正因为异步导致了api设计方式只能采用error-first风格的回调，于是大家硬生生的把callback写成了callback hell。于是各种黑粉就冒出来，无非是一些浅尝辄止之辈。但也正因为回调地狱是最差实践，所以大家才不得不求变，于是thunk、promise等纷沓而至。虽然Promise/A+不完美，但对于解决回调地狱是足够的了。而且随着ES6等规范实现，引入generator、co等，让异步越来越近于同步。当async函数落地的时候，Node已经站在了同C#、Python一样的高度上，大家还有什么理由黑呢？</p>\n<p>本小节先科普一下异步流程里的各种概念，后面会有独立章节进行详细讲解</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>callback</td>\n<td>Node.js API天生就是这样的</td>\n<td></td>\n</tr>\n<tr>\n<td>thunk</td>\n<td>参数的求值策略</td>\n<td></td>\n</tr>\n<tr>\n<td>promise</td>\n<td>最开始是Promise/A+规范，随后成为ES6标准</td>\n<td></td>\n</tr>\n<tr>\n<td>generator</td>\n<td>ES6种的生成器，用于计算，但tj想用做流程控制</td>\n<td></td>\n</tr>\n<tr>\n<td>co</td>\n<td>generator用起来非常麻烦，故而tj写了co这个generator生成器，用法更简单</td>\n<td></td>\n</tr>\n<tr>\n<td>async函数</td>\n<td>原本计划进入es7规范，结果差一点，但好在v8实现了，所以node 7就可以使用，无须等es7规范落地</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>有时，将一件事儿做到极致，也许能有另一种天地</p>\n</blockquote>\n<h2>应用场景</h2>\n<p>MEAN是一个Javascript平台的现代Web开发框架总称，它是MongoDB + Express +AngularJS + NodeJS 四个框架的第一个字母组合。它与传统LAMP一样是一种全套开发工具的简称。在2014和2015年喜欢讲这个，并且还有MEAN.js等框架，但今天已经过时，Node.js有了更多的应用场景。</p>\n<p>《Node.js in action》一书里说，Node所针对的应用程序有一个专门的简称：DIRT。它表示数据密集型实时（data-intensive real-time）程序。因为Node自身在I/O上非常轻量，它善于将数据从一个管道混排或代理到另一个管道上，这能在处理大量请求时持有很多开放的连接，并且只占用一小部分内存。它的设计目标是保证响应能力，跟浏览器一样。</p>\n<p>这话不假，但在今天来看，DIRT还是范围小了。其实DIRT本质上说的I/O处理的都算，但随着大前端的发展，Node.js已经不再只是I/O处理相关，而是更加的“Node”！</p>\n<p>这里给出Node.js的若干使用场景</p>\n<ul>\n<li>网站（如express/koa等）</li>\n<li>im即时聊天(<a href=\"http://socket.io\">socket.io</a>)</li>\n<li>api（移动端，pc，h5）</li>\n<li>HTTP Proxy（淘宝、Qunar、腾讯、百度都有）</li>\n<li>前端构建工具(grunt/gulp/bower/webpack/fis3…)</li>\n<li>写操作系统（NodeOS）</li>\n<li>跨平台打包工具（PC端的electron、nw.js，比如钉钉PC客户端、微信小程序IDE、微信客户端，移动的cordova，即老的Phonegap，还有更加有名的一站式开发框架ionicframework）</li>\n<li>命令行工具（比如cordova、shell.js）</li>\n<li>反向代理（比如anyproxy，node-http-proxy）</li>\n<li>编辑器Atom、VSCode等</li>\n</ul>\n<p>可以说目前大家能够看到的、用到的软件都有Node.js身影，当下最流行的软件写法也大都是基于Node.js的，比如PC客户端<a href=\"https://github.com/luin/medis\">luin/medis</a>采用electron打包，写法采用React+Redux。我自己一直的实践的【Node全栈】，也正是基于这种趋势而形成的。在未来，Node.js的应用场景会更加的广泛。更多参见<a href=\"https://github.com/sindresorhus/awesome-nodejs\">sindresorhus/awesome-nodejs</a>。</p>\n<h3>Web框架</h3>\n<p>演进时间线大致如下：</p>\n<ul>\n<li>2010年tj写的Express</li>\n<li>2011年Derby.js开始开发，8月5日，WalmartLabs的一位成员Eran Hammer提交了Hapi的第一次commit。Hapi原本是Postmile的一部分，并且最开始是基于Express构建的。后来它发展成自己自己的框架，</li>\n<li>2012年1月21日，专注于rest api的restify发布1.0版本，同构的meteor开始投入开发，最像rails的sails也开始了开发</li>\n<li>2013年tj开始玩generator，编写co这个generator执行器，并开始了Koa。2013 年下半年李成银开始ThinkJS，参考ThinkPHP</li>\n<li>2014年，4月9日，express发布4.0，进入4.x时代持续到今天，MEAN.js开始随着MEAN架构的提出开始开发，意图大一统，另外total.js开始，最像PHP’s Laravel 或 Python’s Django 或 <a href=\"http://ASP.NET\">ASP.NET</a> MVC的框架</li>\n<li>2015年8月22日， 下一代Web框架Koa发布1.0，可以在node 0.12下面，通过co + generator实现同步逻辑，那时候co还是基于thunkfy的，2015.10.30 ThinkJS发布了Es2015+ 特性开发的v 2.0版本</li>\n<li>2016 年 09 月，蚂蚁金服的eggjs，在 JSConf China 2016 上亮相并宣布开源</li>\n<li>2017年2月，下一代Web框架Koa发布2.0</li>\n</ul>\n<p>我们可以根据框架的特性进行分类</p>\n<table>\n<thead>\n<tr>\n<th>框架名称</th>\n<th>特性</th>\n<th>点评</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Express</td>\n<td>简单、实用，路由中间件等五脏俱全</td>\n<td>最著名的Web框架</td>\n</tr>\n<tr>\n<td>Derby.js &amp;&amp; Meteor</td>\n<td>同构</td>\n<td>前后端都放到一起，模糊了开发便捷，看上去更简单，实际上上对开发来说要求更高</td>\n</tr>\n<tr>\n<td>Sails、Total</td>\n<td>面向其他语言，Ruby、PHP等</td>\n<td>借鉴业界优秀实现，也是Node.js成熟的一个标志</td>\n</tr>\n<tr>\n<td>MEAN.js</td>\n<td>面向架构</td>\n<td>类似于脚手架，又期望同构，结果只是蹭了热点</td>\n</tr>\n<tr>\n<td>Hapi和Restfy</td>\n<td>面向Api &amp;&amp; 微服务</td>\n<td>移动互联网时代Api的作用被放大，故而独立分类。尤其是对于微服务开发更是利器</td>\n</tr>\n<tr>\n<td>ThinkJS</td>\n<td>面向新特性</td>\n<td>借鉴ThinkPHP，并慢慢走出自己的一条路，对于Async函数等新特性支持，无出其右</td>\n</tr>\n<tr>\n<td>Koa</td>\n<td>专注于异步流程改进</td>\n<td>下一代Web框架</td>\n</tr>\n</tbody>\n</table>\n<p>对于框架选型</p>\n<ul>\n<li>业务场景、特点，不必为了什么而什么，避免本末倒置</li>\n<li>自身团队能力、喜好，有时候技术选型决定团队氛围的，需要平衡激进与稳定</li>\n<li>出现问题的时候，有人能Cover的住，Node.js虽然8年历史，但模块完善程度良莠不齐，如果不慎踩到一个坑里，需要团队在无外力的情况能够搞定，否则会影响进度</li>\n</ul>\n<blockquote>\n<p>个人学习求新，企业架构求稳，无非喜好与场景而已</p>\n</blockquote>\n<p>我猜大家能够想到的场景，大约如下</p>\n<ul>\n<li>前端工具，比如gulp、grunt、webpack等</li>\n<li>服务器，做类似于Java、PHP的事儿</li>\n</ul>\n<p>如果只是做这些，和Java、PHP等就没啥区别了。如果再冠上更了不起的Node.js，就有点名不符实了。所以这里我稍加整理，看看和大家想的是否一样</p>\n<h3>技术栈演进</h3>\n<p>自从ES 2015（俗称ES 6）在Node.js 落地之后，整个Node.js开发都发生了翻天覆地的变化。自从0.10开始，Node.js就逐渐的加入了ES 6特性，比如0.12就可以使用generator，才导致寻求异步流程控制的tj写出了co这个著名的模块，继而诞生了Koa框架。但是在4.0之前，一直都是要通过flag才能开启generator支持，故而Koa 1.0迟迟未发布，在Node 4.0发布才发布的Koa 1.0。</p>\n<blockquote>\n<p>2015年，成熟的传统，而2016年，变革开始</p>\n</blockquote>\n<p>核心变更：es语法支持</p>\n<ul>\n<li>使用Node.js 4.x或5.x里的es6特性，如果想玩更高级的，可以使用<a href>babel</a>编译支持es7特性，或者typescript</li>\n<li>合理使用<a href=\"https://github.com/feross/standard\">standard</a>  或者 xo 代码风格约定</li>\n<li>适当的引入ES 6语法，只要Node.js SDK支持的，都可以使用</li>\n<li>需要大家重视OO（面向对象）写法的学习和使用，虽然ES 6的OO机制不健全，但这是大方向，以后会一直增强。OO对于大型软件开发更好。这其实也是我看好typescript的原因。</li>\n</ul>\n<p>对比一下变革前后的技术栈选型，希望读者能够从中感受到其中的变化</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>2015年</th>\n<th>2016年</th>\n<th>选型原因</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Web框架</td>\n<td>express 4.x</td>\n<td>koa 1.0 &amp;&amp; 2.0 （koa2.0刚发布不久，喜欢折腾的可以考虑）</td>\n<td>主要在流程控制上的便利，异步毕竟要时刻注意，心累</td>\n</tr>\n<tr>\n<td>数据库</td>\n<td>mongoose（mongodb）</td>\n<td>mongoose（mongodb）</td>\n<td>对mongodb和mysql支持都一样，不过是mongodb更简单，足以应付绝大部分场景</td>\n</tr>\n<tr>\n<td>异步流程控制</td>\n<td>bluebird（Promise/A+实现）</td>\n<td>bluebird（Promise/A+实现）1） Koa 1.0 使用co + generator 2） Koa 2.0 使用async函数</td>\n<td>流程控制演进路线，从promise到async函数，无论如何，promise都是基石，必要掌握的</td>\n</tr>\n<tr>\n<td>模板引擎（视图层）</td>\n<td>ejs &amp;&amp; jade</td>\n<td>jade &amp;&amp; nunjucks</td>\n<td>给出了2种，一种可读性好，另一种简洁高效，都是非常好的</td>\n</tr>\n<tr>\n<td>测试</td>\n<td>mocha</td>\n<td>ava</td>\n<td>mocha是Node.js里著名的测试框架，但对新特性的支持没有ava那么好，而ava基于babel安装也要大上好多</td>\n</tr>\n<tr>\n<td>调试</td>\n<td>node-inspector</td>\n<td>VSCode</td>\n<td>在Node 6和7出来之后，node-inspector支持的不是那么好，相反VSCode可视化，简单，文件多时也不卡，特别好用</td>\n</tr>\n</tbody>\n</table>\n<h3>预处理器</h3>\n<p>前端预处理可分3种</p>\n<ul>\n<li>模板引擎</li>\n<li>css预处理器</li>\n<li>js友好语言</li>\n</ul>\n<p>这些都离不开Node.js的支持，对于前端工程师来说，使用Node.js来实现这些是最方便不过的。</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>实现</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>模板引擎</td>\n<td>art\\mustache\\ejs\\hbs\\jade …</td>\n<td>上百种之多，自定义默认，编译成html，继而完成更多操作</td>\n</tr>\n<tr>\n<td>css预处理器</td>\n<td>less\\sass\\scss\\rework\\postcss</td>\n<td>自定义语法规则，编译成css</td>\n</tr>\n<tr>\n<td>js友好语言</td>\n<td>coffeescript、typescript</td>\n<td>自定义语法规则、编译成js</td>\n</tr>\n</tbody>\n</table>\n<h3>跨平台</h3>\n<p>跨平台指的是PC端、移动端、Web/H5</p>\n<table>\n<thead>\n<tr>\n<th>平台</th>\n<th>实现</th>\n<th>点评</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Web/H5</td>\n<td>纯前端</td>\n<td>不必解释</td>\n</tr>\n<tr>\n<td>PC客户端</td>\n<td>nw.js和electron</td>\n<td>尤其是atom和vscode编辑器最为著名，像钉钉PC端，微信客户端、微信小程序IDE等都是这样的，通过web技术来打包成PC客户端</td>\n</tr>\n<tr>\n<td>移动端</td>\n<td>cordova（旧称PhoneGap），基于cordova的ionicframework</td>\n<td>这种采用h5开发，打包成ipa或apk的应用，称为Hybrid开发（混搭），通过webview实现所谓的跨平台，应用的还是非常广泛的</td>\n</tr>\n</tbody>\n</table>\n<h3>构建工具</h3>\n<p>说起构建工具，大概会想到make、ant、rake、gradle等，其实Node.js里有更多实现</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>介绍</th>\n<th>点评</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>jake</td>\n<td>基于coffeescript的大概都熟悉这个，和make、rake类似</td>\n<td>经典传统</td>\n</tr>\n<tr>\n<td>grunt</td>\n<td>dsl风格的早期著名框架</td>\n<td>配置非常麻烦</td>\n</tr>\n<tr>\n<td>gulp</td>\n<td>流式构建，不会产生中间文件，利用Stream机制，处理大文件和内存有优势，配置简单，只有懂点js就能搞定</td>\n<td>grunt的替代品</td>\n</tr>\n<tr>\n<td>webpack + npm scripts</td>\n<td>说是构建工具有点过，但二者组合勉强算吧，loader和plugin机制还是非常强大的</td>\n<td>流行而已</td>\n</tr>\n</tbody>\n</table>\n<p>构建工具都不会特别复杂，所以Node.js世界里有非常多的实现，还有人写过node版本的make呢，玩的很嗨</p>\n<h3>HTTP Proxy</h3>\n<ul>\n<li>请求代理</li>\n<li>SSR &amp;&amp; PWA</li>\n<li>Api Proxy</li>\n</ul>\n<p>1）请求代理</p>\n<p>对于http请求复杂定制的时候，你是需要让Node.js来帮你的，比如为了兼容一个历史遗留需求，在访问某个CSS的时候必须提供HEADER才可以，如果放到静态server或cdn上是做不到的。</p>\n<p>2）SSR &amp;&amp; PWA</p>\n<p>SSR是服务器端渲染，PWA是渐进式Web应用，都是今年最火的技术。如果大家用过，一定对Node.js不陌生。比如React、Vuejs都是Node.js实现的ssr。至于pwa的service-worker也是Node.js实现的。那么为啥不用其他语言实现呢？不是其他语言不能实现，而是使用Node.js简单、方便、学习成本低，轻松获得高性能，如果用其他语言，我至少还得装环境</p>\n<p>3）Api Proxy</p>\n<p>产品需要应变，后端不好变，一变就要设计到数据库、存储等，可能引发事故。而在前端相对更容易，前端只负责组装服务，而非真正对数据库进行变动，所以只要服务api粒度合适，在前端来处理是更好的。</p>\n<p>Api的问题</p>\n<ul>\n<li>一个页面的Api非常多</li>\n<li>跨域，Api转发</li>\n<li>Api返回的数据对前端不友好，后端讨厌（应付）前端，几种api都懒得根据ui/ue去定制，能偷懒就偷懒</li>\n<li>需求决定Api，Api不一定给的及时</li>\n</ul>\n<p>所以，在前端渲染之余，加一层Api Proxy是非常必要的。淘宝早起曾公开过一张架构图，在今天看来，依然不过时</p>\n<p><img src=\"//dn-cnode.qbox.me/Fr8cGvus0i58atULAnoe-Cv4nu5m\" alt=\"taobao.jpg\"></p>\n<ul>\n<li>左侧半边，浏览器和Node.js Server通信可以有多种协议，HTML、RESTfull、BigPipe、Comet、Socket等，已经足够我们完成任何想做的事儿了</li>\n<li>右侧半边，是Node.js实现的WebServer，Node服务分了2个部分\n<ul>\n<li>常规的Http服务，即大块部分二</li>\n<li>ModelProxy指的是根据Server端的服务，组成并转化成自身的Model层。磨蹭用于为Http服务提供更好的接口</li>\n</ul>\n</li>\n</ul>\n<p>这里的Model Proxy其实就是我们所说的Api Proxy，这张图里只是说了结果，把聚合的服务转成模型，继而为HTTP服务提供Api。</p>\n<p>下面我们再深化一下Api Proxy的概念</p>\n<p><img src=\"//dn-cnode.qbox.me/FpAZo4aPQysJyciBvzUCU9uxb-vf\" alt=\"proxy.png\"></p>\n<p>这里的Node Proxy做了2件事儿，Api和渲染辅助。</p>\n<ul>\n<li>前端的异步ajax请求，可以直接访问Api</li>\n<li>如果是直接渲染或者bigpipe等协议的，需要在服务器端组装api，然后再返回给浏览器。</li>\n</ul>\n<p>所以Api后面还有一个服务组装，在微服务架构流行的今天，这种服务组装放到Node Proxy里的好处尤其明显。既可以提高前端开发效率，又可以让后端更加专注于服务开发。甚至如果前端团队足够大，可以在前端建一个Api小组，专门做服务集成的事儿。</p>\n<h3>Api服务</h3>\n<p>说完了Proxy，我们再看看利益问题。Node.js向后端延伸，必然会触动后端开发的利益。那么Proxy层的事儿，前后端矛盾的交界处，后端不想变，前端又求变，那么长此以往，Api接口会变得越来越恶心。后端是愿意把Api的事儿叫前端的，对后端来说，只要你不动我的数据库和服务就可以。</p>\n<p>但是Node.js能不能做这部分呢？答案是能的 ，这个是和Java、PHP类似的，一般是和数据库连接到一起，处理带有业务逻辑的。目前国内大部分都是以Java、PHP等为主，所以要想吃到这部分并不容易。</p>\n<ul>\n<li>小公司，创业公司，新孵化的项目更倾向于Node.js，简单，快速，高效</li>\n<li>微服务架构下的某些服务，使用Node.js开发，是比较合理的</li>\n</ul>\n<p>国内这部分一直没有做的很好，所以Node.js在大公司还没有很好的被应用，安全问题、生态问题、历史遗留问题等，还有很多人对Node.js的误解</p>\n<ul>\n<li>单线程很脆弱，这是事实，但单线程不等于不能多核并发，而且你还有集群呢</li>\n<li>运维，其实很简单，比其他语言之简单，日志采集、监控也非常简单</li>\n<li>模块稳定性，对于Mongodb、MySQL、Redis等还是相当不错，但其他的数据库支持可能没那么好。</li>\n<li>安全问题，</li>\n</ul>\n<p>这些对于提供Api服务来说已经足够了。</p>\n<h3>其他</h3>\n<table>\n<thead>\n<tr>\n<th>用途</th>\n<th>说明</th>\n<th>前景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>爬虫</td>\n<td>抢了不少Python的份额，整体来说简单，实用</td>\n<td>看涨</td>\n</tr>\n<tr>\n<td>命令行工具</td>\n<td>写工具、提高效率，node+npm真是无出其右</td>\n<td>看涨</td>\n</tr>\n<tr>\n<td>微服务与RPC</td>\n<td>Node做纯后端不好做，但在新项目和微服务架构下，必有一席之地</td>\n<td>看涨</td>\n</tr>\n<tr>\n<td>微信公众号开发</td>\n<td>已经火了2年多了，尤其是付费阅读领域，还会继续火下去，gitchat就是使用Node.js做的，而且还在招人</td>\n<td>看涨</td>\n</tr>\n<tr>\n<td>反向代理</td>\n<td>Node.js可以作为nginx这样的反向代理，虽然线上我们很少这样做，但它确确实实可以这样做。比如node-http-proxy和anyproxy等，其实使用Node.js做这种请求转发是非常简单的</td>\n<td>看涨</td>\n</tr>\n</tbody>\n</table>\n<h2>更好的写法</h2>\n<h3>Async函数与Promise</h3>\n<ul>\n<li>Async函数是趋势，Chrome 52. v8 5.1已经支持Async函数(<a href=\"https://github.com/nodejs/CTC/issues/7\">https://github.com/nodejs/CTC/issues/7</a>)了，Node.js 7.0+支持还会远么？</li>\n<li>Async和Generator函数里都支持promise，所以promise是必须会的。</li>\n<li>Generator和yield异常强大，不过不会成为主流，所以学会基本用法和promise就好了，没必要所有的都必须会。</li>\n<li>co作为Generator执行器是不错的，它更好的是当做Promise 包装器，通过Generator支持yieldable，最后返回Promise，是不是有点无耻？</li>\n</ul>\n<p>我整理了一张图，更直观一些。</p>\n<p><img src=\"//dn-cnode.qbox.me/FkcPwxdGHSCHFvA2nU0ub0zYNRt4\" alt=\"async-all.png\"></p>\n<ul>\n<li>红色代表Promise，是使用最多的，无论async还是generator都可用</li>\n<li>蓝色是Generator，过度货</li>\n<li>绿色是Async函数，趋势</li>\n</ul>\n<p><strong>结论</strong>：Promise是必须会的，那你为什么不顺势而为呢？</p>\n<p><strong>推荐</strong>：使用Async函数 + Promise组合，如下图所示。</p>\n<p><img src=\"//dn-cnode.qbox.me/FhVQF1FKB6sNkoFTc3gU-SVnkGtm\" alt=\"async-suggest.png\"></p>\n<p><strong>实践</strong></p>\n<p>合理的结合Promise和Async函数是可以非常高效的，但也要因场景而异</p>\n<ul>\n<li>Promise更容易做promisefyAll（比如使用bluebird）</li>\n<li>Async函数无法批量操作</li>\n</ul>\n<p>那么，在常见的Web应用里，我们总结的实践是，dao层使用Promise比较好，而service层，使用Async/Await更好。</p>\n<p>dao层使用Promise：</p>\n<ul>\n<li>crud</li>\n<li>单一模型的方法多</li>\n<li>库自身支持Promise</li>\n</ul>\n<p>这种用promisefyAll基本几行代码就够了，一般单一模型的操作，不会特别复杂，应变的需求基本不大。</p>\n<p>而service层一般是多个Model组合操作，多模型操作就可以拆分成多个小的操作，然后使用Await来组合，看起来会更加清晰，另外对需求应变也是非常容易的。</p>\n<h3>ES.next</h3>\n<blockquote>\n<p>Node.js + ES.next = ♥</p>\n</blockquote>\n<h3>Flow &amp;&amp; TypeScript</h3>\n<blockquote>\n<p>Type Systems Will Make You a Better JavaScript Developer</p>\n</blockquote>\n<h3>ES6模块</h3>\n<p>现在ES6自带了模块标准， 也是JS第一次支持module（之前的CommonJS、AMD、CMD都不算）， 但目前的所有Node.js版本都没有支持，目前只能用用Traceur、BabelJS， 或者TypeScript把ES6代码转化为兼容ES5版本的js代码，ES6模块新特性非常吸引人，下面简要说明。</p>\n<p>ES6 模块的目标是创建一个同时兼容CommonJS和AMD的格式，语法更加紧凑，通过编译时加载，使得编译时就能确定模块的依赖关系，效率要比 CommonJS 模块的加载方式高。而对于异步加载和配置模块加载方面，则借鉴AMD规范，其效率、灵活程度都远远好于CommonJS写法。</p>\n<ul>\n<li>语法更紧凑</li>\n<li>结构更适于静态编译（比如静态类型检查，优化等）</li>\n<li>对于循环引用支持更好</li>\n</ul>\n<p>ES6 模块标准只有2部分，它的用法更简单，你根本不需要关注实现细节:</p>\n<ul>\n<li>声明式语法：模块导入import、导出export，没有require了</li>\n<li>程式化加载API：可以配置模块是如何加载，以及按需加载。</li>\n</ul>\n<h3>多模块管理器：Lerna</h3>\n<blockquote>\n<p>A tool for managing JavaScript projects with multiple packages.</p>\n</blockquote>\n<p><a href=\"https://lernajs.io/\">https://lernajs.io/</a></p>\n<p>在设计框架的时候，经常做的事儿是进行模块拆分，继而提供插件或集成机制，这样是非常好的做法。但问题也随之而来，当你的模块模块非常多时，你该如何管理你的模块呢？</p>\n<ul>\n<li>法1：每个模块都建立独立的仓库</li>\n<li>法2：所有模块都放到1个仓库里</li>\n</ul>\n<p>法1虽然看起来干净，但模块多时，依赖安装，不同版本兼容等，会导致模块间依赖混乱，出现非常多的重复依赖，极其容易造成版本问题。这时法2就显得更加有效，对于测试，代码管理，发布等，都可以做到更好的支持。</p>\n<p>Lerna就是基于这种初衷而产生的专门用于管理Node.js多模块的工具，当然，前提是你有很多模块需要管理。</p>\n<p>你可以通过npm全局模块来安装Lerna，官方推荐直接使用Lerna 2.x版本</p>\n<h3>更好的NPM替代品：Yarn</h3>\n<p>Yarn是开源JavaScript包管理器，由于npm在扩展内部使用时遇到了大小、性能和安全等问题，Facebook携手来自Exponent、Google和Tilde的工程师，在大型JavaScript框架上打造和测试了Yarn，以便其尽可能适用于多人开发。Yarn承诺比各大流行npm包的安装更可靠，且速度更快。根据你所选的工作包的不同，Yarn可以将安装时间从数分钟减少至几秒钟。Yarn还兼容npm注册表，但包安装方法有所区别。其使用了lockfiles和一个决定性安装算法，能够为参与一个项目的所有用户维持相同的节点模块（node_modules）目录结构，有助于减少难以追踪的bug和在多台机器上复制。</p>\n<p>Yarn还致力于让安装更快速可靠，支持缓存下载的每一个包和并行操作，允许在没有互联网连接的情况下安装（如果此前有安装过的话）。此外，Yarn承诺同时兼容npm和Bower工作流，让你限制安装模块的授权许可。</p>\n<p>2016年10月份, Yarn在横空出世不到一周的时间里，github上的star数已经过万，可以看出大厂及社区的活跃度，以及解决问题的诚意，大概无出其右了！</p>\n<p>替换的原因</p>\n<ul>\n<li>在Facebook的大规模 npm 都工作的不太好</li>\n<li>npm拖慢了公司的ci工作流</li>\n<li>对一个检查所有的模块也是相当低效的</li>\n<li>npm被设计为是不确定性的，而Facebook工程师需要为他们的DevOps工作流提供一直和可依赖的系统</li>\n</ul>\n<p>与hack npm限制的做法相反，Facebook编写了Yarn</p>\n<ul>\n<li>Yarn 的本地缓存文件做的更好</li>\n<li>Yarn 可以并行它的一些操作，这加速了对新模块的安装处理</li>\n<li>Yarn 使用lockfiles，并用确定的算法来创建一个所有跨机器上都一样的文件</li>\n<li>出于安全考虑，在安装进程里，Yarn 不允许编写包的开发者去执行其他代码</li>\n</ul>\n<blockquote>\n<p>Yarn, which promises to even give developers that don’t work at Facebook’s scale a major performance boost, still uses the npm registry and is essentially a drop-in replacement for the npm client.</p>\n</blockquote>\n<p>很多人说和ruby的gem机制类似，都生成lockfile。确实是一个很不错的改进，在速度上有很大改进，配置cnpm等国内源来用，还是相当爽的。</p>\n<h3>友好语言</h3>\n<ul>\n<li>过气的Coffeescript，不多说</li>\n<li><a href=\"https://babeljs.io/\">Babel</a> - also an ES6 to ES5 transpiler that’s growing in popularity possibly because it also supports React’s JSX syntax. As of today it supports the most ES6 features at a somewhat respectable 73%.</li>\n<li><a href=\"http://www.typescriptlang.org/\">TypeScript</a> - a typed superset of JavaScript that not only compiles ES6 to ES5 (or even ES3) but also supports optional variable typing. TypeScript only supports 53% of ES6 features.</li>\n</ul>\n<h2>总结</h2>\n<blockquote>\n<p>坦诚的力量是无穷的</p>\n</blockquote>\n<p>Node.js是为异步而生的，它自己把复杂的事儿做了（高并发，低延时），交给用户的只是有点难用的Callback写法。也正是坦诚的将异步回调暴露出来，才有更好的流程控制方面的演进。也正是这些演进，让Node.js从DIRT（数据敏感实时应用）扩展到更多的应用场景，今天的Node.js已经不只是能写后端的JavaScript，已经涵盖了所有涉及到开发的各个方面，而Node全栈更是热门种的热门。</p>\n<p>直面问题才能有更好的解决方式，Node.js你值得拥有！</p>\n</div>",
        "title": "2017，我们来聊聊 Node.js",
        "last_reply_at": "2017-11-11T06:44:46.540Z",
        "good": true,
        "top": true,
        "reply_count": 165,
        "visit_count": 72904,
        "create_at": "2017-04-13T02:41:41.818Z",
        "author": {
            "loginname": "i5ting",
            "avatar_url": "https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"
        }
    }, {
        "id": "59decbc461932717683d226c",
        "author_id": "55895f5001d3ce0d73d69133",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FitFsUGUKvy8rnoRWjjXYe0NRo1_\" alt=\"640.jpg\"></p>\n<h2>PPT精华</h2>\n<ul>\n<li><a href=\"https://ppt.baomitu.com/d/850e1d13#/\">https://ppt.baomitu.com/d/850e1d13#/</a> 地下铁第五期-未来从启动开始  张挺</li>\n<li><a href=\"https://ppt.baomitu.com/d/2e385fa0#/\">https://ppt.baomitu.com/d/2e385fa0#/</a> Openerable Node App 王子亭</li>\n<li><a href=\"https://ppt.baomitu.com/d/a2521d54#/\">https://ppt.baomitu.com/d/a2521d54#/</a> open-falcon在运维场景的应用和社区生态 高家升</li>\n<li><a href=\"https://ppt.baomitu.com/d/ff574384#/\">https://ppt.baomitu.com/d/ff574384#/</a> WebAssembly 在 Node.js 中的应用 傅晓嵩</li>\n<li><a href=\"https://ppt.baomitu.com/d/14fce0cd#/\">https://ppt.baomitu.com/d/14fce0cd#/</a> ThinkJS 3 的设计与运维 李成银</li>\n</ul>\n<hr>\n<p>我们不仅仅是开发者，也是维护者。</p>\n<p>Node 地下铁已经举办了四期，在不同的领域，我们进行了不少话题选择，而这次，我们的话题是“Ops First（可运维优先）”。</p>\n<p>谈起运维，我们自然都不陌生，它本身是一种职业，更是一种操守，一种负责任的态度，它讲究的不是说将自己的应用变的最好，而是如何稳定，可持续的维护下去。这种态度取决于使用何种方式来做，现有的 Node.js 体系下，我们已经有了一些方案，比如业界的各种集成平台，比如 Alinode，oneAPM 等，也有新兴的自建项目，致力于帮助开发者更好的掌控自己的应用，这些工具或多或少的在帮助应用的运维之路上提供了力所能及的帮助。</p>\n<p>了解并掌握这些工具，熟悉并对应用更有想法，这是在我看来，对维护，开发应用最好的诠释，也是对应用本身的未来，乃至未来接手的一系列维护者最好的礼物了。</p>\n<p>这次我们不一定聊到工具本身，工具只是载体，底层的数据采集，数据链路，数据分析，数据约定等等，每一项都是一门深奥的学问，每一个善于发现美的开发者一定会有自己独到的理解，会从中剖析出适合自己应用的方式，我们希望的，并不只是将工具拿回去应用，更希望能够让大家了解，为什么工具会这么做，应用如何变得更好，更稳定。</p>\n<p>我们挑选了五位嘉宾，跟着大家，一起聊聊将应用变的更好的故事，也期待着大家一起来书写，属于自己的故事。</p>\n<p>十月底，在北京，我们不见不散。</p>\n<p>时间：17-10-28（周六）13:30\n地点：北京·望京东园四区 9 号楼绿地中心 C 座 5F-14 岳麓书院</p>\n<p>话题：</p>\n<p>1、Open-Falcon 在运维场景的应用、接入及社区生态\n2、构建易于运维的 Node.js 后端\n3、ThinkJS 3 的设计与运维\n4、未来从应用启动开始\n5、Web Assembly 在 Node.js 中的最佳实践</p>\n<p>在话题结束后，我们会有一个关于 Ops First 的圆桌讨论，希望大家可以多多交流。</p>\n<p>大家赶紧报名吧。<a href=\"https://survey.alibaba.com/survey/A0QcwiwDR\">https://survey.alibaba.com/survey/A0QcwiwDR</a></p>\n<p>PS：场地有限，报名表单中对于 Ops First 话题提出独到见解和问题的同学优先通过。</p>\n</div>",
        "title": "【PPT】「Ops First」 - Node 地下铁第五期线下沙龙分享和PPT",
        "last_reply_at": "2017-11-08T03:14:33.650Z",
        "good": true,
        "top": true,
        "reply_count": 24,
        "visit_count": 7020,
        "create_at": "2017-10-12T01:56:20.451Z",
        "author": {
            "loginname": "hustxiaoc",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1102038?v=4&s=120"
        }
    }, {
        "id": "58ad76db7872ea0864fedfcc",
        "author_id": "51f0f267f4963ade0e08f503",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FlwW5i2h_UuKpnBXXvD3AqyrwjHP\" alt=\"untitled4.png\"></p>\n<h1>饿了么大前端 Node.js 进阶教程</h1>\n<p>因为 2016 年面试了很多做 Node.js 的同学，发现大部分做 Node 的同学都是前端转过来的，对后端的知识大多一片空白。所以很难招到比较好的 Node.js 服务端程序员（注意，不是全栈）。</p>\n<p>于是出于我们一贯的开源与分享精神，我们筹备了这个名字叫《如何通过饿了么 Node.js 面试》的开源的 Node.js 进阶教程。</p>\n<p>github 仓库地址：<a href=\"https://github.com/ElemeFE/node-interview\">https://github.com/ElemeFE/node-interview</a></p>\n<h3>导读</h3>\n<p>本教程包含 2~3 年经验的 Node.js 服务端需要知道的知识点。</p>\n<p>需要注意的是, 并不适用于零基础的同学, 你需要有一定的 JavaScript/Node.js 基础, 并且有一定的工作经验. 另外本教程的重点更准确的说是服务端基础中 Node.js 程序员需要了解的部分.</p>\n<p>稳重将一些常见的问题划分归类, 每类标明涵盖的一些<code>覆盖点</code>, 并且列举几个<code>常见问题</code>, 通常这些问题都是 2~3 年工作经验需要了解或者面对的. 如果你对某类问题感兴趣, 或者想知道其中列举问题的答案, 可以通过该类下方的 <code>阅读更多</code> 查看更多的内容.</p>\n<p>整体上大纲列举的并不是很全面, 细节上覆盖率不高, 很多讨论只是点到即止, 希望大家带着问题去思考.</p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md\">Js 基础问题</a></h2>\n<blockquote>\n<p>与前端 Js 不同, 后端是直面服务器的, 更加偏向内存方面.</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD\"><code>[Basic]</code> 类型判断</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#%E4%BD%9C%E7%94%A8%E5%9F%9F\"><code>[Basic]</code> 作用域</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92\"><code>[Basic]</code> 引用传递</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE\"><code>[Basic]</code> 内存释放</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#es6-%E6%96%B0%E7%89%B9%E6%80%A7\"><code>[Basic]</code> ES6 新特性</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>js 中什么类型是引用传递, 什么类型是值传递? 如何将值类型的变量以引用的方式传递? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#q-value\">[more]</a></li>\n<li>js 中， 0.1 + 0.2 === 0.3 是否为 true ? 在不知道浮点数位数时应该怎样判断两个浮点数之和与第三数是否相等？</li>\n<li>const 定义的 Array 中间元素能否被修改? 如果可以, 那 const 的意义是? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#q-const\">[more]</a></li>\n<li>JavaScript 中不同类型以及不同环境下变量的内存都是何时释放? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#q-mem\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md\">模块</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md#%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6\"><code>[Basic]</code> 模块机制</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md#%E7%83%AD%E6%9B%B4%E6%96%B0\"><code>[Basic]</code> 热更新</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md#%E4%B8%8A%E4%B8%8B%E6%96%87\"><code>[Basic]</code> 上下文</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>a.js 和 b.js 两个文件互相 require 是否会死循环? 双方是否能导出变量? 如何从设计上避免这种问题? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md#q-loop\">[more]</a></li>\n<li>如果 a.js require 了 b.js, 那么在 b 中定义全局变量 <code>t = 111</code> 能否在 a 中直接打印出来? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md#q-global\">[more]</a></li>\n<li>如何在不重启 node 进程的情况下热更新一个 js/json 文件? 这个问题本身是否有问题? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md#q-hot\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md\">事件/异步</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#promise\"><code>[Basic]</code> Promise</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#events\"><code>[Doc]</code> Events (事件)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#timers\"><code>[Doc]</code> Timers (定时器)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#%E9%98%BB%E5%A1%9E%E5%BC%82%E6%AD%A5\"><code>[Point]</code> 阻塞/异步</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#%E5%B9%B6%E8%A1%8C%E5%B9%B6%E5%8F%91\"><code>[Point]</code> 并行/并发</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>Promise 中 .then 的第二参数与 .catch 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#q-1\">[more]</a></li>\n<li>Eventemitter 的 emit 是同步还是异步? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#q-2\">[more]</a></li>\n<li>如何判断接口是否异步? 是否只要有回调函数就是异步? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#q-3\">[more]</a></li>\n<li>nextTick, setTimeout 以及 setImmediate 三者有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#q-4\">[more]</a></li>\n<li>如何实现一个 sleep 函数? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#q-5\">[more]</a></li>\n<li>如何实现一个异步的 reduce? (注:不是异步完了之后同步 reduce) <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#q-6\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md\">进程</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#process\"><code>[Doc]</code> Process (进程)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#child-process\"><code>[Doc]</code> Child Processes (子进程)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#cluster\"><code>[Doc]</code> Cluster (集群)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1\"><code>[Basic]</code> 进程间通信</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B\"><code>[Basic]</code> 守护进程</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>进程的当前工作目录是什么? 有什么作用? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#q-cwd\">[more]</a></li>\n<li>child_process.fork 与 POSIX 的 fork 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#q-fork\">[more]</a></li>\n<li>父进程或子进程的死亡是否会影响对方? 什么是孤儿进程? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#q-child\">[more]</a></li>\n<li>cluster 是如何保证负载均衡的? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#how-it-works\">[more]</a></li>\n<li>什么是守护进程? 如何实现守护进程? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md\">IO</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#buffer\"><code>[Doc]</code> Buffer</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#string-decoder\"><code>[Doc]</code> String Decoder (字符串解码)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#stream\"><code>[Doc]</code> Stream (流)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#console\"><code>[Doc]</code> Console (控制台)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#file\"><code>[Doc]</code> File System (文件系统)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#readline\"><code>[Doc]</code> Readline</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#repl\"><code>[Doc]</code> REPL</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>Buffer 一般用于处理什么数据? 其长度能否动态变化? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#buffer\">[more]</a></li>\n<li>Stream 的 highWaterMark 与 drain 事件是什么? 二者之间的关系是? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#%E7%BC%93%E5%86%B2%E5%8C%BA\">[more]</a></li>\n<li>Stream 的 pipe 的作用是? 在 pipe 的过程中数据是引用传递还是拷贝传递? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#pipe\">[more]</a></li>\n<li>什么是文件描述符? 输入流/输出流/错误流是什么? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#file\">[more]</a></li>\n<li>console.log 是同步还是异步? 如何实现一个 console.log? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#console\">[more]</a></li>\n<li>如何同步的获取用户的输入?  <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5%E7%9A%84%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E7%9A%84%E8%BE%93%E5%85%A5\">[more]</a></li>\n<li>Readline 是如何实现的? (有思路即可) <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#readline\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md\">Network</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#net\"><code>[Doc]</code> Net (网络)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#udp\"><code>[Doc]</code> UDP/Datagram</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#http\"><code>[Doc]</code> HTTP</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#dns\"><code>[Doc]</code> DNS (域名服务器)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#zlib\"><code>[Doc]</code> ZLIB (压缩)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#rpc\"><code>[Point]</code> RPC</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>cookie 与 session 的区别? 服务端如何清除 cookie? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#q-cookie-session\">[more]</a></li>\n<li>HTTP 协议中的 POST 和 PUT 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#q-post-put\">[more]</a></li>\n<li>什么是跨域请求? 如何允许跨域? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#q-cors\">[more]</a></li>\n<li>TCP/UDP 的区别? TCP 粘包是怎么回事，如何处理? UDP 有粘包吗? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#q-tcp-udp\">[more]</a></li>\n<li><code>TIME_WAIT</code> 是什么情况? 出现过多的 <code>TIME_WAIT</code> 可能是什么原因? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#q-time-wait\">[more]</a></li>\n<li>ECONNRESET 是什么错误? 如何复现这个错误?</li>\n<li>socket hang up 是什么意思? 可能在什么情况下出现? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#socket-hang-up\">[more]</a></li>\n<li>hosts 文件是什么? 什么叫 DNS 本地解析?</li>\n<li>列举几个提高网络传输速度的办法?</li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md\">OS</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#tty\"><code>[Doc]</code> TTY</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#os\"><code>[Doc]</code> OS (操作系统)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#path\"><code>[Doc]</code> Path</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0\"><code>[Doc]</code> 命令行参数</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#%E8%B4%9F%E8%BD%BD\"><code>[Basic]</code> 负载</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#checklist\"><code>[Point]</code> CheckList</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>什么是 TTY? 如何判断是否处于 TTY 环境? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#tty\">[more]</a></li>\n<li>不同操作系统的换行符 (EOL) 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#os\">[more]</a></li>\n<li>服务器负载是什么概念? 如何查看负载? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#%E8%B4%9F%E8%BD%BD\">[more]</a></li>\n<li>ulimit 是用来干什么的? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#ulimit\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md\">错误处理/调试/优化</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#errors\"><code>[Doc]</code> Errors (异常)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#domain\"><code>[Doc]</code> Domain (域)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#debugger\"><code>[Doc]</code> Debugger (调试器)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#c-c++-addon\"><code>[Doc]</code> C/C++ 插件</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#v8\"><code>[Doc]</code> V8</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7\"><code>[Point]</code> 内存快照</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#cpu-profiling\"><code>[Point]</code> CPU profiling</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>怎么处理未预料的出错? 用 try/catch ，domains 还是其它什么? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#q-handle-error\">[more]</a></li>\n<li>什么是 <code>uncaughtException</code> 事件? 一般在什么情况下使用该事件? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#uncaughtexception\">[more]</a></li>\n<li>domain 的原理是? 为什么要弃用 domain? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#domain\">[more]</a></li>\n<li>什么是防御性编程? 与其相对的 let it crash 又是什么?</li>\n<li>为什么要在 cb 的第一参数传 error? 为什么有的 cb 第一个参数不是 error, 例如 http.createServer?</li>\n<li>为什么有些异常没法根据报错信息定位到代码调用? 如何准确的定位一个异常? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#%E9%94%99%E8%AF%AF%E6%A0%88%E4%B8%A2%E5%A4%B1\">[more]</a></li>\n<li>内存泄漏通常由哪些原因导致? 如何分析以及定位内存泄漏? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md\">测试</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95\"><code>[Basic]</code> 测试方法</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95\"><code>[Basic]</code> 单元测试</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95\"><code>[Basic]</code> 集成测试</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95\"><code>[Basic]</code> 基准测试</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95\"><code>[Basic]</code> 压力测试</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#assert\"><code>[Doc]</code> Assert (断言)</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>为什么要写测试? 写测试是否会拖累开发进度?<a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#q-why-write-test\">[more]</a></li>\n<li>单元测试的单元是指什么? 什么是覆盖率?<a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95\">[more]</a></li>\n<li>测试是如何保证业务逻辑中不会出现死循环的?<a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#q-death-loop\">[more]</a></li>\n<li>mock 是什么? 一般在什么情况下 mock?<a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#mock\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md\">util</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#url\"><code>[Doc]</code> URL</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#query-strings\"><code>[Doc]</code> Query Strings (查询字符串)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#util-1\"><code>[Doc]</code> Utilities (实用函数)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><code>[Basic]</code> 正则表达式</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>HTTP 如何通过 GET 方法 (URL) 传递 let arr = [1,2,3,4] 给服务器? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#get-param\">[more]</a></li>\n<li>Node.js 中继承 (util.inherits) 的实现? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#utilinherits\">[more]</a></li>\n<li>如何递归获取某个文件夹下所有的文件名? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#q-traversal\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md\">存储</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#mysql\"><code>[Point]</code> Mysql</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#mongodb\"><code>[Point]</code> Mongodb</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#replication\"><code>[Point]</code> Replication</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7\"><code>[Point]</code> 数据一致性</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#%E7%BC%93%E5%AD%98\"><code>[Point]</code> 缓存</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>备份数据库与 M/S, M/M 等部署方式的区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#replication\">[more]</a></li>\n<li>索引有什么用，大致原理是什么? 设计索引有什么注意点? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#%E7%B4%A2%E5%BC%95\">[more]</a></li>\n<li>Monogdb 连接问题(超时/断开等)有可能是什么问题导致的? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#Mongodb\">[more]</a></li>\n<li>什么情况下数据会出现脏数据? 如何避免? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7\">[more]</a></li>\n<li>redis 与 memcached 的区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#%E7%BC%93%E5%AD%98\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md\">安全</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#crypto\"><code>[Doc]</code> Crypto (加密)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#tlsssl\"><code>[Doc]</code> TLS/SSL</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#https\"><code>[Doc]</code> HTTPS</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#xss\"><code>[Point]</code> XSS</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#csrf\"><code>[Point]</code> CSRF</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB\"><code>[Point]</code> 中间人攻击</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#sqlnosql-%E6%B3%A8%E5%85%A5\"><code>[Point]</code> Sql/Nosql 注入</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>加密是如何保证用户密码的安全性? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#crypto\">[more]</a></li>\n<li>TLS 与 SSL 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#tlsssl\">[more]</a></li>\n<li>HTTPS 能否被劫持? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#https\">[more]</a></li>\n<li>XSS 攻击是什么? 有什么危害? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#xss\">[more]</a></li>\n<li>过滤 Html 标签能否防止 XSS? 请列举不能的情况? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#xss\">[more]</a></li>\n<li>CSRF 是什么? 如何防范? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#csrf\">[more]</a></li>\n<li>如何避免中间人攻击? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md\">阅读更多</a></p>\n<h2>最后</h2>\n<p>目前 repo 处于施工现场的情况，如果发现问题欢迎在 <a href=\"https://github.com/ElemeFE/node-interview/issues\">issues</a> 中指出。如果有比较好的<code>问题/知识点/指正</code>，也欢迎提 PR。</p>\n<p>另外关于 <code>Js 基础</code> 是个比较大的话题，在本教程不会很细致深入的讨论，更多的是列出一些重要或者更服务端更相关的地方，所以如果你拿着《JavaScript 权威指南》给教程提 PR 可能不会采纳。本教程的重点更准确的说是服务端基础中 Node.js 程序员需要了解的部分。</p>\n</div>",
        "title": "饿了么大前端 Node.js 进阶教程",
        "last_reply_at": "2017-11-07T02:47:31.264Z",
        "good": true,
        "top": true,
        "reply_count": 268,
        "visit_count": 179026,
        "create_at": "2017-02-22T11:32:43.547Z",
        "author": {
            "loginname": "lellansin",
            "avatar_url": "https://avatars2.githubusercontent.com/u/2081487?v=4&s=120"
        }
    }, {
        "id": "5a099a2b001f0eb571c1b07d",
        "author_id": "564582ec5e7412b625b8bf16",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p>我最近基于vs2015 开发了一个简单的动态库测试程序，在vs环境下调用dll 是没有问题的，但是在node-gyp环境中就是编译不通过，请大神给我一个demo，最好是可以运行的，感激不尽。</p>\n</div>",
        "title": "node.js关于c++原生模块中调用动态/静态库的问题",
        "last_reply_at": "2017-11-13T13:12:11.030Z",
        "good": false,
        "top": false,
        "reply_count": 0,
        "visit_count": 5,
        "create_at": "2017-11-13T13:12:11.030Z",
        "author": {
            "loginname": "RajanZhan",
            "avatar_url": "https://avatars1.githubusercontent.com/u/15818327?v=4&s=120"
        }
    }, {
        "id": "5a094028a57c17282e12062d",
        "author_id": "5943d411ff5813233faad924",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/Fp6JG02z9HZMXm5VcJAFr4WjS5M3\" alt=\"WechatIMG432.jpeg\">\n<img src=\"//dn-cnode.qbox.me/Fi529pDgVWS2FfF34GShhiR-R8VK\" alt=\"1510555628581.jpg\">\n爬的是接口，因为接口的数据会时不时的更新，所以我设置的是十几秒抓一次。\n测试了一段时间后，我发现接口更新的数据，并没有抓回来。\n想问问大家的想法。</p>\n</div>",
        "title": "关于爬虫的一个小问题",
        "last_reply_at": "2017-11-13T13:06:01.358Z",
        "good": false,
        "top": false,
        "reply_count": 2,
        "visit_count": 92,
        "create_at": "2017-11-13T06:48:08.877Z",
        "author": {
            "loginname": "Kevinzhang29",
            "avatar_url": "https://avatars3.githubusercontent.com/u/29355109?v=4&s=120"
        }
    }, {
        "id": "5a053112e5ae82da2ec4fe2b",
        "author_id": "54009f5ccd66f2eb37190485",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><p>【没目标向钱看，有目标向前看】扯那些都没用，为啥烧饼会打到你头上？狼叔说点接地气的实话</p>\n<p>没目标的时候向钱看。哪个賺钱做哪个，一般市场导向都是对的，程序员领域也一样\n有目标就向前看。人还是要为信仰而活，无论说什么信仰，哪怕说财务自由\n无论结果如何，自己开心就好。一般努力的人没有太坏的结果。比如我去创业被坑死，但我的技能和生活圈子明显高了很多，损失的自然有别处可以补回来。人生如梦，tomorrow is another day！</p>\n<p>更新：</p>\n<p>有的钱不是什么时候都能赚的，比如技能储备不足，去分享讲课，容易打脸。</p>\n<p>有的时候时候钱会来找你，就说明你积累的已经差不多了。</p>\n<p>网友说：长得丑的也要向钱看，哈哈哈</p>\n<p><a href=\"https://www.zhihu.com/question/67597689/answer/257792066\">https://www.zhihu.com/question/67597689/answer/257792066</a></p>\n</div>",
        "title": "程序员如何实现财务自由？",
        "last_reply_at": "2017-11-13T12:50:42.184Z",
        "good": false,
        "top": false,
        "reply_count": 3,
        "visit_count": 467,
        "create_at": "2017-11-10T04:54:42.281Z",
        "author": {
            "loginname": "i5ting",
            "avatar_url": "https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"
        }
    }, {
        "id": "5a0981cedea908392cfc891b",
        "author_id": "58d39d9003d476b42d34c684",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/Fgk6vxc65VJVPeUOhmxMZv4FqqkF\" alt=\"image.png\">\n我想在 VersionLog.vue 文件 直接引入 markdown ,要怎么做，\n在网上找的都是 markdown 编辑器，我不要那种的，我需要能直接解析掉，不用编辑器\nVersionLog.vue</p>\n<pre class=\"prettyprint language-html\"><code>&lt;template lang=&quot;html&quot;&gt;\n &lt;div class=&quot;&quot; id=&#x27;editor&#x27;&gt;\n\n   &lt;!-- Log start --&gt;\n   &lt;div class=&quot;article&quot; v-html=&quot;compiledMarkdown&quot;&gt;&lt;&#x2F;div&gt;\n   &lt;!-- Log end --&gt;\n\n &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport marked from &#x27;marked&#x27;\nexport default {\n name: &#x27;Log&#x27;,\n data () {\n return {\n  context: &quot;&quot;\n }\n},\n\ncomputed:{\n  compiledMarkdown () {\n    return marked(this.context, { sanitize: true })\n  }\n}\n}\n&lt;&#x2F;script&gt;\n\n</code></pre></div>",
        "title": "怎么在 vue 文件直接引入 markdown 进行解析",
        "last_reply_at": "2017-11-13T11:28:14.960Z",
        "good": false,
        "top": false,
        "reply_count": 0,
        "visit_count": 29,
        "create_at": "2017-11-13T11:28:14.960Z",
        "author": {
            "loginname": "vxhly",
            "avatar_url": "https://avatars0.githubusercontent.com/u/17906558?v=4&s=120"
        }
    }, {
        "id": "5a098139001f0eb571c1b07c",
        "author_id": "56ac4d7f26d02fc6626bb3b1",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p><a href=\"//parent.js\">//parent.js</a></p>\n<pre class=\"prettyprint\"><code>&#x27;use strict&#x27;\nvar os = require(&quot;os&quot;)\nvar child_process = require(&quot;child_process&quot;)\nvar server = require(&quot;net&quot;).createServer();\n\nvar workers;\n\nfor(var i = 0; i&lt; 1; i++){\n\tworkers = child_process.fork(&quot;.&#x2F;child.js&quot;)\n}\n\nserver.listen(8080, function(){\n\tconsole.log(&quot;333333&quot;)\n\tworkers.send(&quot;server&quot;,server)\n\tserver.close()&#x2F;&#x2F;如果将这行注释的话，请求过快会导致程序卡死\n})\n</code></pre><p><a href=\"//child.js\">//child.js</a></p>\n<pre class=\"prettyprint\"><code>&quot;use strict&quot;\nvar http = require(&quot;http&quot;)\nhttp.globalAgent.maxSockets = Infinity\nvar taskList = []\nvar server = http.createServer(function(req, res){\n\ttaskList.push(req.url)\n\tres.writeHead(200, {&quot;Content-Type&quot;: &quot;text&#x2F;plain&quot;});\n\tres.end(&quot;handled by child, pid is &quot; + process.pid +&quot;\\n&quot;)\n});\n\nprocess.on(&quot;message&quot;, function(m, tcp){\n\tconsole.log(&quot;11111111111&quot;)\n\tif(m == &quot;server&quot;){\n\t\tvar worker = tcp;\n\t\tworker.on(&quot;connection&quot;, function(socket){\n\t\t\tconsole.log(&quot;2222222222&quot;)\n\t\t\tserver.emit(&quot;connection&quot;, socket);\n\t\t})\n\n\t}\n});\n</code></pre></div>",
        "title": "急:为什么nodejs主进程发送句柄给子进程，如果请求过快会导致卡死,但是如果把主进程服务关闭却不会出现卡死的情况呢！",
        "last_reply_at": "2017-11-13T11:25:45.427Z",
        "good": false,
        "top": false,
        "reply_count": 0,
        "visit_count": 36,
        "create_at": "2017-11-13T11:25:45.427Z",
        "author": {
            "loginname": "oyosc",
            "avatar_url": "https://avatars1.githubusercontent.com/u/13896491?v=4&s=120"
        }
    }, {
        "id": "5a095aa5a57c17282e12063d",
        "author_id": "5a0534d7ee9b35da75a86a0a",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p>.query可以获取接口能直接console出来，ctx.body无法得到console出来的内容</p>\n<pre class=\"prettyprint\"><code>router.all(&#x27;&#x2F;publ&#x2F;tongji&#x27;,async(ctx,next)=&gt;{\n    await db.query(&quot;SELECT * FROM &#96;class&#96;;&quot;,\n        (err,data)=&gt;{\n            if(err){\n                ctx.body = err;\n            }\n            else{\n                ctx.body = data;\n            }\n        });\n    next();\n});\n</code></pre><p>上段代码中ctx.body无法获取数据 但是console.log能够获取数据。</p>\n<pre class=\"prettyprint\"><code>router.all(&#x27;&#x2F;publ&#x2F;tongji&#x27;,async(ctx,next)=&gt;{\n    ctx.body = await db.query(&quot;SELECT * FROM &#96;class&#96;;&quot;,\n        (err,data)=&gt;{\n            if(err){\n                &#x2F;&#x2F;console.log(err);\n                return err;\n            }\n            else{\n                &#x2F;&#x2F;console.log(data);\n                return data;\n            }\n        });\n    next();\n});\n</code></pre><p>依然不行，新手一枚往大家多多指教</p>\n</div>",
        "title": "koa2.连接sql内容无法展示到ctx.body中",
        "last_reply_at": "2017-11-13T10:24:14.862Z",
        "good": false,
        "top": false,
        "reply_count": 2,
        "visit_count": 65,
        "create_at": "2017-11-13T08:41:09.820Z",
        "author": {
            "loginname": "SuSuy",
            "avatar_url": "https://avatars1.githubusercontent.com/u/17306440?v=4&s=120"
        }
    }, {
        "id": "5a06cb2bf7915d6c49ea40d7",
        "author_id": "5a05efe8c0d9e76145350f43",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><blockquote>\n<p>我在setTimeout 里面调用Fibres</p>\n<p>结果在操作数据的时候  FIBERS.current;  报错Error: yield() called with no fiber running  请教一下各位大神.这种问题怎么解决啊???</p>\n</blockquote>\n</div>",
        "title": "请问一下.Fibres不能异步调用么?",
        "last_reply_at": "2017-11-13T10:18:23.196Z",
        "good": false,
        "top": false,
        "reply_count": 1,
        "visit_count": 127,
        "create_at": "2017-11-11T10:04:27.240Z",
        "author": {
            "loginname": "522422474",
            "avatar_url": "https://avatars1.githubusercontent.com/u/18393385?v=4&s=120"
        }
    }, {
        "id": "5a014cbe235953e84e47d543",
        "author_id": "5110f2bedf9e9fcc584e4677",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><p>Promise 想必大家十分熟悉，想想就那么几个 api，可是你真的了解 Promise 吗？本文根据 Promise 的一些知识点总结了十道题，看看你能做对几道。</p>\n<h3>题目一</h3>\n<pre class=\"prettyprint language-js\"><code>const promise = new Promise((resolve, reject) =&gt; {\n  console.log(1)\n  resolve()\n  console.log(2)\n})\npromise.then(() =&gt; {\n  console.log(3)\n})\nconsole.log(4)\n</code></pre><h3>题目二</h3>\n<pre class=\"prettyprint language-js\"><code>const promise1 = new Promise((resolve, reject) =&gt; {\n  setTimeout(() =&gt; {\n    resolve(&#x27;success&#x27;)\n  }, 1000)\n})\nconst promise2 = promise1.then(() =&gt; {\n  throw new Error(&#x27;error!!!&#x27;)\n})\n\nconsole.log(&#x27;promise1&#x27;, promise1)\nconsole.log(&#x27;promise2&#x27;, promise2)\n\nsetTimeout(() =&gt; {\n  console.log(&#x27;promise1&#x27;, promise1)\n  console.log(&#x27;promise2&#x27;, promise2)\n}, 2000)\n</code></pre><h3>题目三</h3>\n<pre class=\"prettyprint language-js&#x27;\"><code>const promise = new Promise((resolve, reject) =&gt; {\n  resolve(&#x27;success1&#x27;)\n  reject(&#x27;error&#x27;)\n  resolve(&#x27;success2&#x27;)\n})\n\npromise\n  .then((res) =&gt; {\n    console.log(&#x27;then: &#x27;, res)\n  })\n  .catch((err) =&gt; {\n    console.log(&#x27;catch: &#x27;, err)\n  })\n</code></pre><h3>题目四</h3>\n<pre class=\"prettyprint language-js\"><code>Promise.resolve(1)\n  .then((res) =&gt; {\n    console.log(res)\n    return 2\n  })\n  .catch((err) =&gt; {\n    return 3\n  })\n  .then((res) =&gt; {\n    console.log(res)\n  })\n</code></pre><h3>题目五</h3>\n<pre class=\"prettyprint language-js\"><code>const promise = new Promise((resolve, reject) =&gt; {\n  setTimeout(() =&gt; {\n    console.log(&#x27;once&#x27;)\n    resolve(&#x27;success&#x27;)\n  }, 1000)\n})\n\nconst start = Date.now()\npromise.then((res) =&gt; {\n  console.log(res, Date.now() - start)\n})\npromise.then((res) =&gt; {\n  console.log(res, Date.now() - start)\n})\n</code></pre><h3>题目六</h3>\n<pre class=\"prettyprint language-js\"><code>Promise.resolve()\n  .then(() =&gt; {\n    return new Error(&#x27;error!!!&#x27;)\n  })\n  .then((res) =&gt; {\n    console.log(&#x27;then: &#x27;, res)\n  })\n  .catch((err) =&gt; {\n    console.log(&#x27;catch: &#x27;, err)\n  })\n</code></pre><h3>题目七</h3>\n<pre class=\"prettyprint language-js\"><code>const promise = Promise.resolve()\n  .then(() =&gt; {\n    return promise\n  })\npromise.catch(console.error)\n</code></pre><h3>题目八</h3>\n<pre class=\"prettyprint language-js\"><code>Promise.resolve(1)\n  .then(2)\n  .then(Promise.resolve(3))\n  .then(console.log)\n</code></pre><h3>题目九</h3>\n<pre class=\"prettyprint language-js\"><code>Promise.resolve()\n  .then(function success (res) {\n    throw new Error(&#x27;error&#x27;)\n  }, function fail1 (e) {\n    console.error(&#x27;fail1: &#x27;, e)\n  })\n  .catch(function fail2 (e) {\n    console.error(&#x27;fail2: &#x27;, e)\n  })\n</code></pre><h3>题目十</h3>\n<pre class=\"prettyprint language-js\"><code>process.nextTick(() =&gt; {\n  console.log(&#x27;nextTick&#x27;)\n})\nPromise.resolve()\n  .then(() =&gt; {\n    console.log(&#x27;then&#x27;)\n  })\nsetImmediate(() =&gt; {\n  console.log(&#x27;setImmediate&#x27;)\n})\nconsole.log(&#x27;end&#x27;)\n</code></pre><h2>结果</h2>\n<p>执行结果及解释见我的知乎文章：<a href=\"https://zhuanlan.zhihu.com/p/30797777\">https://zhuanlan.zhihu.com/p/30797777</a></p>\n</div>",
        "title": "Promise 必知必会（十道题）",
        "last_reply_at": "2017-11-13T09:58:51.614Z",
        "good": true,
        "top": false,
        "reply_count": 14,
        "visit_count": 1280,
        "create_at": "2017-11-07T06:03:42.337Z",
        "author": {
            "loginname": "nswbmw",
            "avatar_url": "https://avatars0.githubusercontent.com/u/4279697?v=4&s=120"
        }
    }, {
        "id": "59fd4552b4e1470c1673d045",
        "author_id": "59100e61d371b6372a8af69d",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p>看到北京有<img src=\"https://cnodejs.org/topic/59decbc461932717683d226c\" alt=\"node地下铁\">的技术分享活动，想参加类似的活动学习技术，所以请问各位大佬，广州有木有类似的线下活动啊？😁</p>\n</div>",
        "title": "请问广州有哪些nodejs的技术分享活动吗？",
        "last_reply_at": "2017-11-13T09:54:02.201Z",
        "good": false,
        "top": false,
        "reply_count": 17,
        "visit_count": 552,
        "create_at": "2017-11-04T04:42:58.784Z",
        "author": {
            "loginname": "Tseian",
            "avatar_url": "https://avatars0.githubusercontent.com/u/13184460?v=4&s=120"
        }
    }, {
        "id": "59f31f6724df5d7e438b7028",
        "author_id": "57637029c13e1e492222bd2d",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><h3>github地址：<a href=\"https://github.com/YMFE/yapi\">https://github.com/YMFE/yapi</a></h3>\n<h3>文档 <a href=\"http://yapi.qunar.com\">http://yapi.qunar.com</a></h3>\n<h3>特性</h3>\n<ul>\n<li>基于 Json5 和 Mockjs 定义接口返回数据的结构和文档，效率提升多倍</li>\n<li>扁平化权限设计，即保证了大型企业级项目的管理，又保证了易用性</li>\n<li>类似 postman 的接口调试</li>\n<li>自动化测试, 支持对 Response 断言</li>\n<li>MockServer 除支持普通的随机 mock 外，还增加了 Mock 期望功能，根据设置的请求过滤规则，返回期望数据</li>\n<li>支持 postman, har, swagger 数据导入</li>\n<li>免费开源，内网部署，信息再也不怕泄露了</li>\n<li>支持接口文档导出为 markdown ,html</li>\n</ul>\n<p>自动化测试视频地址：<a href=\"http://yapi.demo.qunar.com/publicapi/auto-test.mp4\">http://yapi.demo.qunar.com/publicapi/auto-test.mp4</a>\n欢迎大家使用，已经部署的朋友可以使用 yapi-cli 工具更新</p>\n</div>",
        "title": "YApi 发布 v1.2.0 版本，支持了高级 mock 和自动化测试（内附自动化测试演示视频）",
        "last_reply_at": "2017-11-13T09:53:17.903Z",
        "good": false,
        "top": false,
        "reply_count": 13,
        "visit_count": 628,
        "create_at": "2017-10-27T11:58:31.708Z",
        "author": {
            "loginname": "suxiaoxin",
            "avatar_url": "https://avatars0.githubusercontent.com/u/17695103?v=4&s=120"
        }
    }, {
        "id": "5a041d4fad77fa200454918b",
        "author_id": "4efc278525fa69ac690000fc",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><p><strong><a href=\"https://github.com/keelii/awesome-host-manager\">Awesome-host-manager</a></strong></p>\n<h2>应用截图</h2>\n<p><img src=\"https://img20.360buyimg.com/devfe/jfs/t11611/80/1444685331/28555/590b5dfa/5a013f0aN19565830.png\" alt=\"ahm-640x440\"></p>\n<p><a href=\"https://img20.360buyimg.com/devfe/jfs/t11845/332/1453803626/635686/c8e4f98/5a013fe8N41db44e3.png\"><img src=\"https://img20.360buyimg.com/devfe/jfs/t11845/332/1453803626/635686/c8e4f98/5a013fe8N41db44e3.png\" alt=\"ahm-1280x800\"></a></p>\n<h2>功能</h2>\n<ul>\n<li>秒切 host 无延迟 😎</li>\n<li>基于 chrome 代理 ❤️</li>\n<li>兼容 socket 代理 🤔</li>\n<li>简洁好用，无多余功能 👏</li>\n</ul>\n<h2>安装</h2>\n<ul>\n<li><a href=\"https://chrome.google.com/webstore/detail/awesome-host-manager/pikaoeecieigblebdddckmlegonlogha?hl=zh-CN\">Chrome 应用商店</a>（建议）</li>\n<li><a href=\"https://raw.githubusercontent.com/keelii/awesome-host-manager/master/awesome-host-manager.crx\">下载 .crx 文件</a> chrome 中打开 chrome://extensions/ 将.crx 文件托进安装即可</li>\n</ul>\n<h2>使用</h2>\n<h4>Host proxy</h4>\n<p>和 host 文件规则一致</p>\n<pre class=\"prettyprint\"><code>192.168.100.1 your.domain.com your-anther.domain.com\n</code></pre><h4>Socket proxy</h4>\n<p>新建分组加入以下规则（按自己实际情况修改）</p>\n<pre class=\"prettyprint\"><code>SOCKS5 127.0.0.1:1080\nSOCKS 127.0.0.1:1080\n</code></pre><h2>源代码</h2>\n<p><a href=\"https://github.com/keelii/awesome-host-manager\">Github</a>(MIT)</p>\n</div>",
        "title": "发布一个 host 管理插件",
        "last_reply_at": "2017-11-13T09:32:17.623Z",
        "good": false,
        "top": false,
        "reply_count": 3,
        "visit_count": 230,
        "create_at": "2017-11-09T09:18:07.880Z",
        "author": {
            "loginname": "keelii",
            "avatar_url": "//gravatar.com/avatar/e507492193afb2822dda0f1ceddf8940?size=48"
        }
    }, {
        "id": "5a09583b310be7561d4c041c",
        "author_id": "59eeb8e11bbf067d5c3fa7c6",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><h1>EggBorn.js Showcase: Watch Articles</h1>\n<p>这是EggBorn.js的案例，同时也是一个强大的工具，可以自动抓取文章的统计数字，诸如visits、 stars、 replies，等等。</p>\n<blockquote>\n<p>Vue.js + Framework7 + Koa.js + Egg.js + MySQL + GitHub Passport</p>\n</blockquote>\n<h2>主要演示特性</h2>\n<ul>\n<li>模块异步加载</li>\n<li>Framework7 Tabs View布局</li>\n<li>全局Indicator显示与隐藏</li>\n<li>“上拉刷新”与“下拉加载”</li>\n<li>LoadMore组件设计</li>\n<li>Form Validate</li>\n<li>Login页面跳转逻辑</li>\n<li>GitHub Passport整合</li>\n</ul>\n<h2>体验案例</h2>\n<h3>官网</h3>\n<ul>\n<li>网址：<a href=\"http://wa.egg-born.org\">http://wa.egg-born.org</a></li>\n<li>二维码：\n<img src=\"//dn-cnode.qbox.me/FkFEbUegxjMSZPj4uD1NqToZOrAy\" alt=\"qrcode.png\"></li>\n</ul>\n<h3>截图</h3>\n<p><img src=\"//dn-cnode.qbox.me/FoLqn-OGBw_YJoBosXO9z4EBNA4k\" alt=\"1.jpg\"></p>\n<p><img src=\"//dn-cnode.qbox.me/FgnXBuEMKgt39zWwWb1iSF7587MU\" alt=\"2.jpg\"></p>\n<h3>如何使用</h3>\n<p>将文章添加进系统，系统会使用相应的模式代码自动抓取文章的统计数字。如果没有相应的模式代码，您也可以创建一个。</p>\n<h3>模式库</h3>\n<p>欢迎fork仓库<a href=\"https://github.com/zhennann/watch-articles\">watch-articles</a>，创建您自己的模块代码，提交<a href=\"https://github.com/zhennann/watch-articles/pulls\">PR</a>，然后发布到这里！</p>\n<table>\n<thead>\n<tr>\n<th>模式代码</th>\n<th>作者</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>github-repo</td>\n<td><a href=\"https://github.com/zhennann\">zhennann</a></td>\n</tr>\n<tr>\n<td>cnode-topic</td>\n<td><a href=\"https://github.com/zhennann\">zhennann</a></td>\n</tr>\n<tr>\n<td>juejin-im-post</td>\n<td><a href=\"https://github.com/zhennann\">zhennann</a></td>\n</tr>\n</tbody>\n</table>\n<h2>快速开始</h2>\n<h3>安装</h3>\n<pre class=\"prettyprint language-bash\"><code>$ npm install\n</code></pre><h3>配置MySQL</h3>\n<p>修改文件: <code>src/backend/config/config.default.js</code></p>\n<pre class=\"prettyprint language- javascript\"><code>  &#x2F;&#x2F; mysql\n  config.mysql = {\n    clients: {\n      &#x2F;&#x2F; donot change the name  \n      __ebdb: {\n        host: &#x27;127.0.0.1&#x27;,\n        port: &#x27;3306&#x27;,\n        user: &#x27;travis&#x27;,\n        password: &#x27;&#x27;,\n        database: &#x27;watch-articles&#x27;,\n      },\n    },\n  };\n</code></pre><h3>运行</h3>\n<p>启动后端服务</p>\n<pre class=\"prettyprint language-bash\"><code>$ npm run dev:backend\n</code></pre><p>启动前端服务</p>\n<pre class=\"prettyprint language-bash\"><code>$ npm run dev:front\n</code></pre><h3>测试</h3>\n<pre class=\"prettyprint language-bash\"><code>$ npm run test:backend\n$ npm run cov:backend\n</code></pre><h3>GitHub</h3>\n<p><a href=\"https://github.com/zhennann/egg-born-showcase-watch-articles\">https://github.com/zhennann/egg-born-showcase-watch-articles</a></p>\n</div>",
        "title": "EggBorn.js Showcase: Watch Articles",
        "last_reply_at": "2017-11-13T08:50:06.633Z",
        "good": false,
        "top": false,
        "reply_count": 1,
        "visit_count": 65,
        "create_at": "2017-11-13T08:30:51.088Z",
        "author": {
            "loginname": "zhennann",
            "avatar_url": "https://avatars1.githubusercontent.com/u/24246985?v=4&s=120"
        }
    }, {
        "id": "5a0956fcdea908392cfc890b",
        "author_id": "5a095617a57c17282e12063c",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p>2017-11-13 16:23:01.601 xcodebuild[24568:190947] [MT] PluginLoading: Required plug-in compatibility UUID DFFB3951-EB0A-4C09-9DAC-5F2D28CC839C for plug-in at path ‘~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/VVDocumenter-Xcode.xcplugin’ not present in DVTPlugInCompatibilityUUIDs\nCC(target) Release/obj.target/ffi/deps/libffi/src/prep_cif.o\nCC(target) Release/obj.target/ffi/deps/libffi/src/types.o\nCC(target) Release/obj.target/ffi/deps/libffi/src/raw_api.o\nCC(target) Release/obj.target/ffi/deps/libffi/src/java_raw_api.o\nCC(target) Release/obj.target/ffi/deps/libffi/src/closures.o\nCC(target) Release/obj.target/ffi/deps/libffi/src/x86/ffi.o\nCC(target) Release/obj.target/ffi/deps/libffi/src/x86/ffi64.o\nCC(target) Release/obj.target/ffi/deps/libffi/src/x86/darwin.o\nCC(target) Release/obj.target/ffi/deps/libffi/src/x86/darwin64.o\nLIBTOOL-STATIC Release/libffi.a\nlibtool: unrecognized option <code>-static' libtool: Try</code>libtool --help’ for more information.\nmake: *** [Release/libffi.a] Error 1</p>\n</div>",
        "title": "node install ffi报错，大神们，求解答",
        "last_reply_at": "2017-11-13T08:25:32.864Z",
        "good": false,
        "top": false,
        "reply_count": 0,
        "visit_count": 43,
        "create_at": "2017-11-13T08:25:32.864Z",
        "author": {
            "loginname": "zhangrss",
            "avatar_url": "https://avatars3.githubusercontent.com/u/4928491?v=4&s=120"
        }
    }, {
        "id": "5a051c74ee9b35da75a869f8",
        "author_id": "56ebae5df8b53f5936f2e61f",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p>目前环境\n&quot;egg&quot;: “^1.9.0”,\n“egg-sequelize”: “^3.1.0”,\n下面这段sequelize查询代码\n<img src=\"//dn-cnode.qbox.me/FjR24EiRTegqJyk9-pVrIgoNbkJT\" alt=\"WechatIMG198.jpeg\">\n当返回结果数据量大的时候，报错heap out of memory，\n当用上述代码生成的sql直接用model.query查询时没问题，\n求教问题根源</p>\n</div>",
        "title": "求教sequelize相关问题",
        "last_reply_at": "2017-11-13T08:01:19.651Z",
        "good": false,
        "top": false,
        "reply_count": 4,
        "visit_count": 235,
        "create_at": "2017-11-10T03:26:44.292Z",
        "author": {
            "loginname": "MUHM",
            "avatar_url": "https://avatars0.githubusercontent.com/u/14190805?v=3&s=120"
        }
    }, {
        "id": "5a0734bf42df5ebf48fa932d",
        "author_id": "59f9da9ab381c1737d7ccb9f",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p>感觉自己静不下心来深入学习了，好想有人带啊…</p>\n<p>来自酷炫的 <a href=\"https://github.com/TakWolf/CNode-Material-Design\">CNodeMD</a></p>\n</div>",
        "title": "学习遇到了瓶颈吗……",
        "last_reply_at": "2017-11-13T07:13:33.562Z",
        "good": false,
        "top": false,
        "reply_count": 8,
        "visit_count": 330,
        "create_at": "2017-11-11T17:34:55.585Z",
        "author": {
            "loginname": "Alexerx",
            "avatar_url": "https://avatars3.githubusercontent.com/u/22076610?v=4&s=120"
        }
    }, {
        "id": "5a03d21b84ed7ceb219ea83d",
        "author_id": "5a03d028ad77fa200454916a",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><p>链接：<a href=\"https://chun-chat.herokuapp.com\">https://chun-chat.herokuapp.com</a></p>\n<ul>\n<li>使用MEVN技术栈 + socket.io开发。使用Vuex管理组件状态。</li>\n<li>前后端分离，后端（Nodejs）提供API, 对应操作数据库资源. 前端（Vuejs）发送API请求, 更新视图.</li>\n<li>注册表实现后端验证, 用户输入时检查邮箱和用户名是否被注册, 注册表使用reCAPTCHA提供验证功能. 前端使用vee-validate检查用户输入, 后端使用express-validator检查POST body. 使用passport定义登录策略. 使用bcrypt加密, 比较用户密码.</li>\n<li>使用JWT实现用户登录。用户登录成功后将用户基本信息编码得到JWT，使用cookie存放JWT。</li>\n<li>允许用户注册, 登录, 登出, 上传图片修改头像, 发布个性签名, 添加表情. 允许用户搜索好友, 添加好友, 实时接收好友请求. 提供消息提示, 好友请求提示, 对方正在输入提示. 根据朋友性别更改聊天气泡颜色. 按需加载历史聊天记录, 允许用户删除聊天. 记录在线用户, 防止账号同时登陆. 定时更新好友信息.</li>\n</ul>\n<p>** 头像图床用的imgur, 大陆的ip不能上传图片。。。</p>\n<p>新手轻喷~~~</p>\n<p>我的用户名是junlinguo11，欢迎加我嘻嘻</p>\n</div>",
        "title": "新手用MEVN写了一个在线聊天app~~",
        "last_reply_at": "2017-11-13T06:26:17.779Z",
        "good": false,
        "top": false,
        "reply_count": 6,
        "visit_count": 421,
        "create_at": "2017-11-09T03:57:15.376Z",
        "author": {
            "loginname": "junlinguo11",
            "avatar_url": "https://avatars1.githubusercontent.com/u/20136619?v=4&s=120"
        }
    }, {
        "id": "5a057fc1ee9b35da75a86a32",
        "author_id": "5966cfadb3b22664747cc895",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><h3>front-end</h3>\n<pre class=\"prettyprint language-js\"><code>webpack --color --watch\n</code></pre><h4>这样前端文件修改后，webpack会watch，</h4>\n<h3>back-end</h3>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F;koa-static 加载静态文件\napp.use(koaStatic( path.resolve(&#x27;.&#x2F;dist&#x27;), {\n    maxAge: 356 * 24 * 60 * 60\n}))\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npm2 start app.js --watch\npm2 log\n</code></pre><h4>这样后端文件修改了后，PM2 会自动重启nodejs，PM2 log 查看最新日志</h4>\n<p><img src=\"//dn-cnode.qbox.me/FmOzeVt_n2mBvhAU4TaDxDzD1n4a\" alt=\"image.png\"></p>\n</div>",
        "title": "突然发现个(webpack+nodejs)便捷的调试方式",
        "last_reply_at": "2017-11-13T06:09:24.833Z",
        "good": false,
        "top": false,
        "reply_count": 2,
        "visit_count": 296,
        "create_at": "2017-11-10T10:30:25.183Z",
        "author": {
            "loginname": "pengliheng",
            "avatar_url": "https://avatars2.githubusercontent.com/u/14355994?v=4&s=120"
        }
    }, {
        "id": "5939fa64d3575f1303de3aab",
        "author_id": "590d7e623504ce1c2ac45912",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><blockquote>\n<p>文章目录：\n        <a href=\"http://cnodejs.org/topic/59294bff9e32cc84569a746a\">1.Node.js 接入微信公众平台开发</a>\n        <a href=\"http://cnodejs.org/topic/5933d125739a92064a1bd4b6\">2.Node.js access_token的获取、存储及更新</a>\n        <a href=\"https://cnodejs.org/topic/593668946b7ebe7e2979d8c6\">3.Node.js 自定义微信菜单</a>\n        <a href=\"https://cnodejs.org/topic/5939fa64d3575f1303de3aab\">4.Node.js 微信消息管理</a></p>\n</blockquote>\n<h1>一、写在前面的话</h1>\n<p>  当用户发送消息给公众号时（或某些特定的用户操作引发的事件推送时），会产生一个POST请求，开发者可以在响应包（Get）中返回特定XML结构，来对该消息进行响应。</p>\n<p>  消息推送也是微信公众号开发更为有趣的功能，涉及到文本消息、图片消息、语音消息、视频消息、音乐消息以及图文消息。并且最为有趣的功能当属消息加解密了，当然由于篇文章篇幅的原因我会在下一篇文章中去着重说明。</p>\n<p><img src=\"http://img.blog.csdn.net/20170608132911792?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"我们接着来，微信消息管理\"></p>\n<h1>二、微信消息管理</h1>\n<p>1.捕获消息信息</p>\n<p>  在文章的第一句话中,为我们指明了微信消息产生的请求方式为 POST，因此首先我们就去对 Node.js 的 Post 请求进行监听。</p>\n<p>  在我们的 app.js 文件中添加一个POST监听，并将获取的结果输出：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F;用于处理所有进入 3000 端口 post 的连接请求\napp.post(&#x27;&#x2F;&#x27;,function(req,res){\n    var buffer = [];\n    &#x2F;&#x2F;监听 data 事件 用于接收数据\n    req.on(&#x27;data&#x27;,function(data){\n        buffer.push(data);\n    });\n    &#x2F;&#x2F;监听 end 事件 用于处理接收完成的数据\n    req.on(&#x27;end&#x27;,function(){\n    &#x2F;&#x2F;输出接收完成的数据   \n         console.log(Buffer.concat(buffer).toString(&#x27;utf-8&#x27;));\n    });\n});\n</code></pre><p>  随后将 Node.js 启动后映射至外网，关注我们的微信公众号，在控制台中则会看到：\n<img src=\"http://img.blog.csdn.net/20170607140400511?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"输出结果\"></p>\n<p>  打开 <a href=\"https://mp.weixin.qq.com/wiki\">微信帮助文档 </a>，点击左侧菜单的消息管理，选择其子菜单 接收事件推送，如图：\n<img src=\"http://img.blog.csdn.net/20170608135040728?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"消息管理 -  接收事件推送\"></p>\n<p><img src=\"http://img.blog.csdn.net/20170608143204731?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"微信接收事件推送\"></p>\n<p>  从上图我们不难看出，微信 接收事件推送 确实很多，而我们最终目标是要实现，在用户触发事件时返回其相应的回复消息。因此我们总结一下我们要实现的步骤：</p>\n<ol>\n<li>解析 XML ，使用 Event 参数判断事件类型</li>\n<li>返回相应的事件信息</li>\n</ol>\n<p>总结完实现步骤后，我们就开始动手实现第一个被动回复消息吧。</p>\n<p><img src=\"http://img.blog.csdn.net/20170608144308940?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"别拦我，让我去装逼\"></p>\n<p>2.以关注事件为例，实现第一个被动回复</p>\n<p>  解析 XML 我这里使用了 第三方的包 xml2js(npm install xml2js )，并在 wechat.js 中引入。</p>\n<pre class=\"prettyprint language-javascript\"><code> parseString = require(&#x27;xml2js&#x27;).parseString;&#x2F;&#x2F;引入xml2js包\n</code></pre><p>  为 WeChat 对象添加一个消息处理的方法 handleMsg，将 app.js 中捕获 POST 实现的写入在其代码块中，并使用 xml2js 解析，代码如下</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;**\n * 微信消息\n *&#x2F;\nWeChat.prototype.handleMsg = function(req,res){\n    var buffer = [];\n    &#x2F;&#x2F;监听 data 事件 用于接收数据\n    req.on(&#x27;data&#x27;,function(data){\n        buffer.push(data);\n    });\n    &#x2F;&#x2F;监听 end 事件 用于处理接收完成的数据\n    req.on(&#x27;end&#x27;,function(){\n        var msgXml = Buffer.concat(buffer).toString(&#x27;utf-8&#x27;);\n        &#x2F;&#x2F;解析xml\n        parseString(msgXml,{explicitArray : false},function(err,result){\n            if(!err){\n                &#x2F;&#x2F;打印解析结果\n                console.log(result);\n            }else{\n                 &#x2F;&#x2F;打印错误信息\n                console.log(err);\n            }\n        })\n    });\n}\n</code></pre><p>  在 app.js 中调用 handleMsg 方法</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F;用于处理所有进入 3000 端口 post 的连接请求\napp.post(&#x27;&#x2F;&#x27;,function(req,res){\n    wechatApp.handleMsg(req,res);\n});\n</code></pre><p>  完成了代码的编写后，将公众号重新关注\n<img src=\"http://img.blog.csdn.net/20170608150730880?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"运行结果\"></p>\n<p>最后打印为一个 JSON 格式的结果，也就是预示着我们第1步工作已经完成。下面开始我们的第2步，微信被动回复。</p>\n<p>  在文章的第一句话的后边提到 开发者可以在响应包（Get）中返回特定XML结构，那么这个特定的 XML 结构在哪呢？再次打开<a href=\"https://mp.weixin.qq.com/wiki\">微信帮助文档 </a>，点击左侧菜单的消息管理，选择其子菜单 被动回复消息，如图：\n<img src=\"http://img.blog.csdn.net/20170608151816018?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"消息管理 - 被动回复消息\"></p>\n<p>  直接来到 回复文本消息：\n<img src=\"http://img.blog.csdn.net/20170608152541242?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"回复文本消息\"></p>\n<p>  拿到回复文本消息格式后，我们就来为关注我们公众号的同学打声招呼吧。在 wechat 文件中 创建 msg.js 文件用于消息的管理。\n<img src=\"http://img.blog.csdn.net/20170608153001089?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>并在 msg.js 中添加处理文本消息的接口，并在 wechat.js 中引用</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x27;use strict&#x27; &#x2F;&#x2F;设置为严格模式\n\n&#x2F;&#x2F;回复文本消息\nexports.txtMsg = function(toUser,fromUser,content){\n    var xmlContent =  &quot;&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[&quot;+ toUser +&quot;]]&gt;&lt;&#x2F;ToUserName&gt;&quot;;\n        xmlContent += &quot;&lt;FromUserName&gt;&lt;![CDATA[&quot;+ fromUser +&quot;]]&gt;&lt;&#x2F;FromUserName&gt;&quot;;\n        xmlContent += &quot;&lt;CreateTime&gt;&quot;+ new Date().getTime() +&quot;&lt;&#x2F;CreateTime&gt;&quot;;\n        xmlContent += &quot;&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;&#x2F;MsgType&gt;&quot;;\n        xmlContent += &quot;&lt;Content&gt;&lt;![CDATA[&quot;+ content +&quot;]]&gt;&lt;&#x2F;Content&gt;&lt;&#x2F;xml&gt;&quot;;\n    return xmlContent;\n}\n</code></pre><p>修改 wechat.js 中 handleMsg 方法</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;**\n * 微信消息\n *&#x2F;\nWeChat.prototype.handleMsg = function(req,res){\n    var buffer = [];\n    &#x2F;&#x2F;监听 data 事件 用于接收数据\n    req.on(&#x27;data&#x27;,function(data){\n        buffer.push(data);\n    });\n    &#x2F;&#x2F;监听 end 事件 用于处理接收完成的数据\n    req.on(&#x27;end&#x27;,function(){\n        var msgXml = Buffer.concat(buffer).toString(&#x27;utf-8&#x27;);\n        &#x2F;&#x2F;解析xml\n        parseString(msgXml,{explicitArray : false},function(err,result){\n            if(!err){\n                   result = result.xml;\n                   var toUser = result.ToUserName; &#x2F;&#x2F;接收方微信\n                   var fromUser = result.FromUserName;&#x2F;&#x2F;发送仿微信\n                   &#x2F;&#x2F;判断事件类型\n                   switch(result.Event.toLowerCase()){\n                      case &#x27;subscribe&#x27;:\n                             &#x2F;&#x2F;回复消息\n                             res.send(msg.txtMsg(fromUser,toUser,&#x27;欢迎关注 hvkcoder 公众号，一起斗图吧&#x27;));\n                             break;\n                   }\n            }else{\n                 &#x2F;&#x2F;打印错误信息\n                console.log(err);\n            }\n        })\n    });\n}\n</code></pre><p><img src=\"http://img.blog.csdn.net/20170608160434723?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"实现结果\"></p>\n<p>   没错就是这么简单。这里有个逻辑是这样的 toUser 表示接收方，也就是咱们的微信公众号；fromUser 表示发送方，也就是触发事件的用户。而我们要回复用户时，此时 接收方 就是 触发事件的用户，而发送方则是 我们的微信公众号。这块比较绕，大家可以慢慢去理解。</p>\n<p>  由于我们还没有对微信的素材管理进行讲解，这里我们暂时跳过 图片消息、语音消息、视频消息、以及音乐消息。直接实现图文消息的推送。</p>\n<p>3.图文消息\n<img src=\"http://img.blog.csdn.net/20170608165627419?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\">\n  在 msg.js 文件中添加图文XML模板</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F;回复图文消息\nexports.graphicMsg = function(toUser,fromUser,contentArr){\n     var xmlContent =  &quot;&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[&quot;+ toUser +&quot;]]&gt;&lt;&#x2F;ToUserName&gt;&quot;;\n        xmlContent += &quot;&lt;FromUserName&gt;&lt;![CDATA[&quot;+ fromUser +&quot;]]&gt;&lt;&#x2F;FromUserName&gt;&quot;;\n        xmlContent += &quot;&lt;CreateTime&gt;&quot;+ new Date().getTime() +&quot;&lt;&#x2F;CreateTime&gt;&quot;;\n        xmlContent += &quot;&lt;MsgType&gt;&lt;![CDATA[news]]&gt;&lt;&#x2F;MsgType&gt;&quot;;\n        xmlContent += &quot;&lt;ArticleCount&gt;&quot;+contentArr.length+&quot;&lt;&#x2F;ArticleCount&gt;&quot;;\n        xmlContent += &quot;&lt;Articles&gt;&quot;;\n        contentArr.map(function(item,index){\n            xmlContent+=&quot;&lt;item&gt;&quot;;\n            xmlContent+=&quot;&lt;Title&gt;&lt;![CDATA[&quot;+ item.Title +&quot;]]&gt;&lt;&#x2F;Title&gt;&quot;;\n            xmlContent+=&quot;&lt;Description&gt;&lt;![CDATA[&quot;+ item.Description +&quot;]]&gt;&lt;&#x2F;Description&gt;&quot;;\n            xmlContent+=&quot;&lt;PicUrl&gt;&lt;![CDATA[&quot;+ item.PicUrl +&quot;]]&gt;&lt;&#x2F;PicUrl&gt;&quot;;\n            xmlContent+=&quot;&lt;Url&gt;&lt;![CDATA[&quot;+ item.Url +&quot;]]&gt;&lt;&#x2F;Url&gt;&quot;;\n            xmlContent+=&quot;&lt;&#x2F;item&gt;&quot;;\n        });\n        xmlContent += &quot;&lt;&#x2F;Articles&gt;&lt;&#x2F;xml&gt;&quot;;\n    return xmlContent;\n}\n}\n</code></pre><p>  更改 wechat.js 文件中的 handleMsg 方法，将图消息推送响应在点击事件中</p>\n<pre class=\"prettyprint language-javascript\"><code>  case &#x27;click&#x27;:\n                                var contentArr = [\n                                    {Title:&quot;Node.js 微信自定义菜单&quot;,Description:&quot;使用Node.js实现自定义微信菜单&quot;,PicUrl:&quot;http:&#x2F;&#x2F;img.blog.csdn.net&#x2F;20170605162832842?watermark&#x2F;2&#x2F;text&#x2F;aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=&#x2F;font&#x2F;5a6L5L2T&#x2F;fontsize&#x2F;400&#x2F;fill&#x2F;I0JBQkFCMA==&#x2F;dissolve&#x2F;70&#x2F;gravity&#x2F;SouthEast&quot;,Url:&quot;http:&#x2F;&#x2F;blog.csdn.net&#x2F;hvkcoder&#x2F;article&#x2F;details&#x2F;72868520&quot;},\n                                    {Title:&quot;Node.js access_token的获取、存储及更新&quot;,Description:&quot;Node.js access_token的获取、存储及更新&quot;,PicUrl:&quot;http:&#x2F;&#x2F;img.blog.csdn.net&#x2F;20170528151333883?watermark&#x2F;2&#x2F;text&#x2F;aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=&#x2F;font&#x2F;5a6L5L2T&#x2F;fontsize&#x2F;400&#x2F;fill&#x2F;I0JBQkFCMA==&#x2F;dissolve&#x2F;70&#x2F;gravity&#x2F;SouthEast&quot;,Url:&quot;http:&#x2F;&#x2F;blog.csdn.net&#x2F;hvkcoder&#x2F;article&#x2F;details&#x2F;72783631&quot;},\n                                    {Title:&quot;Node.js 接入微信公众平台开发&quot;,Description:&quot;Node.js 接入微信公众平台开发&quot;,PicUrl:&quot;http:&#x2F;&#x2F;img.blog.csdn.net&#x2F;20170605162832842?watermark&#x2F;2&#x2F;text&#x2F;aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=&#x2F;font&#x2F;5a6L5L2T&#x2F;fontsize&#x2F;400&#x2F;fill&#x2F;I0JBQkFCMA==&#x2F;dissolve&#x2F;70&#x2F;gravity&#x2F;SouthEast&quot;,Url:&quot;http:&#x2F;&#x2F;blog.csdn.net&#x2F;hvkcoder&#x2F;article&#x2F;details&#x2F;72765279&quot;}\n                                ];\n                               &#x2F;&#x2F;回复图文消息\n                               res.send(msg.graphicMsg(fromUser,toUser,contentArr));\n                            break;\n</code></pre><p>  点击菜单下的 今日推荐\n<img src=\"http://img.blog.csdn.net/20170608174606626?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"今日推荐\"></p>\n<p>  图文推送就是这么简单的被我们给实现了。</p>\n<p>4.接收普通消息</p>\n<p>  微信除了为我们接收事件推送外，千万不要忘了微信还能通过发送文字。而这一节我们也就来玩玩微信接收普通消息。</p>\n<p>  打开 <a href=\"https://mp.weixin.qq.com/wiki\">微信帮助文档 </a>，点击左侧菜单的消息管理，选择其子菜单 接收普通消息，如图：\n<img src=\"http://img.blog.csdn.net/20170608175735412?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"消息管理 - 接收普通消息\"></p>\n<p>  依然如接收事件推送的套路，不同的是参数发生了改变，但这并步影响我们的开发，只需要几步就能够完美的解决。更改 wechat.js 文件 handleMsg方法，这里我先暂时只针对用户输入的文本消息做处理，其他的跟其类似。</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F;判断消息类型\n                   if(result.MsgType.toLowerCase() === &quot;event&quot;){\n                        &#x2F;&#x2F;判断事件类型\n                        switch(result.Event.toLowerCase()){\n                            case &#x27;subscribe&#x27;:\n                                    &#x2F;&#x2F;回复消息\n                                    var content = &quot;欢迎关注 hvkcoder 公众号，一起斗图吧。回复以下数字：\\n&quot;;\n                                        content += &quot;1.你是谁\\n&quot;;\n                                        content += &quot;2.关于Node.js\\n&quot;;\n                                        content += &quot;回复 “文章”  可以得到图文推送哦~\\n&quot;;\n                                    res.send(msg.txtMsg(fromUser,toUser,&#x27;&#x27;));\n                                    break;\n                            case &#x27;click&#x27;:\n                                        var contentArr = [\n                                            {Title:&quot;Node.js 微信自定义菜单&quot;,Description:&quot;使用Node.js实现自定义微信菜单&quot;,PicUrl:&quot;http:&#x2F;&#x2F;img.blog.csdn.net&#x2F;20170605162832842?watermark&#x2F;2&#x2F;text&#x2F;aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=&#x2F;font&#x2F;5a6L5L2T&#x2F;fontsize&#x2F;400&#x2F;fill&#x2F;I0JBQkFCMA==&#x2F;dissolve&#x2F;70&#x2F;gravity&#x2F;SouthEast&quot;,Url:&quot;http:&#x2F;&#x2F;blog.csdn.net&#x2F;hvkcoder&#x2F;article&#x2F;details&#x2F;72868520&quot;},\n                                            {Title:&quot;Node.js access_token的获取、存储及更新&quot;,Description:&quot;Node.js access_token的获取、存储及更新&quot;,PicUrl:&quot;http:&#x2F;&#x2F;img.blog.csdn.net&#x2F;20170528151333883?watermark&#x2F;2&#x2F;text&#x2F;aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=&#x2F;font&#x2F;5a6L5L2T&#x2F;fontsize&#x2F;400&#x2F;fill&#x2F;I0JBQkFCMA==&#x2F;dissolve&#x2F;70&#x2F;gravity&#x2F;SouthEast&quot;,Url:&quot;http:&#x2F;&#x2F;blog.csdn.net&#x2F;hvkcoder&#x2F;article&#x2F;details&#x2F;72783631&quot;},\n                                            {Title:&quot;Node.js 接入微信公众平台开发&quot;,Description:&quot;Node.js 接入微信公众平台开发&quot;,PicUrl:&quot;http:&#x2F;&#x2F;img.blog.csdn.net&#x2F;20170605162832842?watermark&#x2F;2&#x2F;text&#x2F;aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=&#x2F;font&#x2F;5a6L5L2T&#x2F;fontsize&#x2F;400&#x2F;fill&#x2F;I0JBQkFCMA==&#x2F;dissolve&#x2F;70&#x2F;gravity&#x2F;SouthEast&quot;,Url:&quot;http:&#x2F;&#x2F;blog.csdn.net&#x2F;hvkcoder&#x2F;article&#x2F;details&#x2F;72765279&quot;}\n                                        ];\n                                    &#x2F;&#x2F;回复图文消息\n                                    res.send(msg.graphicMsg(fromUser,toUser,contentArr));\n                                    break;\n                        }\n                   }else{\n                       &#x2F;&#x2F;判断消息类型为 文本消息\n                       if(result.MsgType.toLowerCase() === &quot;text&quot;){\n                           &#x2F;&#x2F;根据消息内容返回消息信息\n                           switch(result.Content){\n                               case &#x27;1&#x27;:\n                                        res.send(msg.txtMsg(fromUser,toUser,&#x27;Hello ！我的英文名字叫 H-VK&#x27;));\n                                    break;\n                               case &#x27;2&#x27;:\n                                        res.send(msg.txtMsg(fromUser,toUser,&#x27;Node.js是一个开放源代码、跨平台的JavaScript语言运行环境，采用Google开发的V8运行代码,使用事件驱动、非阻塞和异步输入输出模型等技术来提高性能，可优化应用程序的传输量和规模。这些技术通常用于数据密集的事实应用程序&#x27;));\n                                    break;\n                               case &#x27;文章&#x27;:\n                                      var contentArr = [\n                                            {Title:&quot;Node.js 微信自定义菜单&quot;,Description:&quot;使用Node.js实现自定义微信菜单&quot;,PicUrl:&quot;http:&#x2F;&#x2F;img.blog.csdn.net&#x2F;20170605162832842?watermark&#x2F;2&#x2F;text&#x2F;aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=&#x2F;font&#x2F;5a6L5L2T&#x2F;fontsize&#x2F;400&#x2F;fill&#x2F;I0JBQkFCMA==&#x2F;dissolve&#x2F;70&#x2F;gravity&#x2F;SouthEast&quot;,Url:&quot;http:&#x2F;&#x2F;blog.csdn.net&#x2F;hvkcoder&#x2F;article&#x2F;details&#x2F;72868520&quot;},\n                                            {Title:&quot;Node.js access_token的获取、存储及更新&quot;,Description:&quot;Node.js access_token的获取、存储及更新&quot;,PicUrl:&quot;http:&#x2F;&#x2F;img.blog.csdn.net&#x2F;20170528151333883?watermark&#x2F;2&#x2F;text&#x2F;aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=&#x2F;font&#x2F;5a6L5L2T&#x2F;fontsize&#x2F;400&#x2F;fill&#x2F;I0JBQkFCMA==&#x2F;dissolve&#x2F;70&#x2F;gravity&#x2F;SouthEast&quot;,Url:&quot;http:&#x2F;&#x2F;blog.csdn.net&#x2F;hvkcoder&#x2F;article&#x2F;details&#x2F;72783631&quot;},\n                                            {Title:&quot;Node.js 接入微信公众平台开发&quot;,Description:&quot;Node.js 接入微信公众平台开发&quot;,PicUrl:&quot;http:&#x2F;&#x2F;img.blog.csdn.net&#x2F;20170605162832842?watermark&#x2F;2&#x2F;text&#x2F;aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=&#x2F;font&#x2F;5a6L5L2T&#x2F;fontsize&#x2F;400&#x2F;fill&#x2F;I0JBQkFCMA==&#x2F;dissolve&#x2F;70&#x2F;gravity&#x2F;SouthEast&quot;,Url:&quot;http:&#x2F;&#x2F;blog.csdn.net&#x2F;hvkcoder&#x2F;article&#x2F;details&#x2F;72765279&quot;}\n                                        ];\n                                        &#x2F;&#x2F;回复图文消息\n                                        res.send(msg.graphicMsg(fromUser,toUser,contentArr));\n                                    break;\n                                default :\n                                         res.send(msg.txtMsg(fromUser,toUser,&#x27;没有这个选项哦&#x27;));\n                                    break;\n                           }\n                       }\n                   }\n</code></pre><p><img src=\"http://img.blog.csdn.net/20170608183907918?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"微信消息 文本消息处理\"></p>\n<p><img src=\"http://img.blog.csdn.net/20170608183936497?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"微信消息 文本消息处理\"></p>\n<p><img src=\"http://img.blog.csdn.net/20170608184008076?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"测试微信公众号\"></p>\n<p>  OK ！至此我们就完成了微信消息管理的讲解，似乎真的没有什么难度。预留了一章，主要想要去细说一下说消息加解密，因为在网上涉及 Node.js 微信消息加解密的文章确实很少，微信帮助文档给的案例也没有 Node.js 的详细说明。</p>\n<p>  最后文章代码部分，由于网上编辑器的代码换行做的不是很好可能有些乱，建议可以去我的 github 上查看源码。</p>\n<p>  文章源代码：<a href=\"https://github.com/SilenceHVK/wechatByNode\">https://github.com/SilenceHVK/wechatByNode</a> 。对文章有不正确之处，请给予纠正。github源代码请顺手给个 Star，最后感谢您的阅读。</p>\n</div>",
        "title": "4.Node.js 微信消息管理",
        "last_reply_at": "2017-11-13T05:35:32.563Z",
        "good": true,
        "top": false,
        "reply_count": 12,
        "visit_count": 5101,
        "create_at": "2017-06-09T01:31:16.239Z",
        "author": {
            "loginname": "SilenceHVK",
            "avatar_url": "https://avatars3.githubusercontent.com/u/12862565?v=4&s=120"
        }
    }, {
        "id": "5a0545cb88c853c52fd5682a",
        "author_id": "58edae8949056f03483477e8",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p>我在维护一个论坛,数据库打算更换到mongodb, 然后遇到了这样一些问题\n查询大概是这样的步骤:</p>\n<pre class=\"prettyprint\"><code>数据表T,  数组A[objectid关联 表T]\n1.筛选T得到结果1;\n2.从数组A中拓展得到结果2;\n3.合并结果1结果2,得到结果3;\n4.筛选排序结果3,得到最终结果;\n</code></pre><p>第一个问题: 这样的查询MONGO怎么实现?\n第二个问题: 在aggregate中如何返回这种结果(分页)</p>\n<pre class=\"prettyprint\"><code>{\n\tlength: x,\n\tdocuments: [\n\t\tdoc1,\n\t\t...\n\t]\n}\n</code></pre></div>",
        "title": "请教大家一个数据库设计的问题",
        "last_reply_at": "2017-11-13T05:20:22.026Z",
        "good": false,
        "top": false,
        "reply_count": 1,
        "visit_count": 246,
        "create_at": "2017-11-10T06:23:07.025Z",
        "author": {
            "loginname": "lzszone",
            "avatar_url": "https://avatars0.githubusercontent.com/u/16443301?v=4&s=120"
        }
    }, {
        "id": "5a08377ea57c17282e12060e",
        "author_id": "59f5e5f47d3866d655408260",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><p>我也不知道</p>\n</div>",
        "title": "怎么办？///",
        "last_reply_at": "2017-11-13T03:44:46.447Z",
        "good": false,
        "top": false,
        "reply_count": 2,
        "visit_count": 165,
        "create_at": "2017-11-12T11:58:54.230Z",
        "author": {
            "loginname": "woshilina",
            "avatar_url": "https://avatars0.githubusercontent.com/u/28744945?v=4&s=120"
        }
    }, {
        "id": "5a04f6c888c853c52fd56808",
        "author_id": "56ff5d8e8265278d59c7e46f",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><p>nodejs服务间如何通信，还是走http么，貌似没有有关tcp方面的框架，我想用node做一个中间层下游node没有及时处理请求时，单线程阻塞时，做些异常处理并响应相关静态资源</p>\n</div>",
        "title": "nodejs服务间如何通信",
        "last_reply_at": "2017-11-13T03:44:35.029Z",
        "good": false,
        "top": false,
        "reply_count": 11,
        "visit_count": 474,
        "create_at": "2017-11-10T00:46:00.716Z",
        "author": {
            "loginname": "yudawei1230",
            "avatar_url": "https://avatars.githubusercontent.com/u/15976653?v=3&s=120"
        }
    }, {
        "id": "5a0705bbf31111711f3a770a",
        "author_id": "55afa32c9594740e76ab3e2e",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p>现在是双向墙。墙内上不去总比墙外上不去好。\n趁着还没被盯上要求实行实名制，赶快搬吧！</p>\n<p><a href=\"/user/alsotang\">@alsotang</a></p>\n</div>",
        "title": "把CNode搬到国外吧！",
        "last_reply_at": "2017-11-13T03:35:05.461Z",
        "good": false,
        "top": false,
        "reply_count": 2,
        "visit_count": 426,
        "create_at": "2017-11-11T14:14:19.942Z",
        "author": {
            "loginname": "dou4cc",
            "avatar_url": "https://avatars2.githubusercontent.com/u/7764678?v=4&s=120"
        }
    }, {
        "id": "5a056bd6ee9b35da75a86a21",
        "author_id": "57bb18956b04813133ba909b",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><h3>前言</h3>\n<p>自己写的图片上传工具个人中心页要展示一个用户头像，但是自己又不想去写自定义头像上传的代码。所以前期先使用默认头像吧，可是要是每个人都使用一样的头像又觉得很怪异。你是否记得你在注册完github的时候会给你分配一个默认头像，有点像二维码。后来去Google下这种头像叫做哈希头像，是根据一个hash值来随机生成的。下面介绍如何使用nodejs生成hash头像\n<img src=\"http://fs.andylistudio.com/1510298709122.png\" alt=\"哈希头像\"></p>\n<h3>安装依赖</h3>\n<pre class=\"prettyprint\"><code>npm install identicon.js --save\nnpm install crypto --save \n</code></pre><p>identicon就是用来生成hash头像的npm包，它能根据一个hash值，生成随机头像对象的base64码。那么怎么生成hash值呢？就得用到crypto，根据每个用户的用户名生成一个hash值。</p>\n<h3>代码</h3>\n<pre class=\"prettyprint language-js\"><code>import crypto from &#x27;crypto&#x27;\nimport Identicon from &#x27;identicon.js&#x27;\n\nlet hash = crypto.createHash(&#x27;md5&#x27;)\nhash.update(&#x27;andyliwr&#x27;); &#x2F;&#x2F; 传入用户名\nlet imgData = new Identicon(hash.digest(&#x27;hex&#x27;)).toString()\nlet imgUrl = &#x27;data:image&#x2F;png;base64,&#x27;+imgData &#x2F;&#x2F; 这就是头像的base64码\n</code></pre><h3>参考资料</h3>\n<p><a href=\"https://github.com/stewartlord/identicon.js\">identicon.js</a>\n<a href=\"https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434501504929883d11d84a1541c6907eefd792c0da51000\">crypto的使用</a></p>\n<h3>打个广告</h3>\n<p>欢迎各位使用我的<a href=\"http://upload.andylistudio.com\">图片上传工具</a>，只要拖一拖，图片上传加压缩，链接永不丢失。</p>\n<p>详情请查考我的博客 <a href=\"http://www.andylistudio.com/2017/11/08/nodejs_identicon/\">http://www.andylistudio.com/2017/11/08/nodejs_identicon/</a></p>\n</div>",
        "title": "如何使用nodejs生成哈希头像---identicons",
        "last_reply_at": "2017-11-13T03:00:15.716Z",
        "good": false,
        "top": false,
        "reply_count": 2,
        "visit_count": 195,
        "create_at": "2017-11-10T09:05:26.588Z",
        "author": {
            "loginname": "Andyliwr",
            "avatar_url": "https://avatars1.githubusercontent.com/u/12456160?v=4&s=120"
        }
    }, {
        "id": "5a090a20001f0eb571c1b046",
        "author_id": "57bb18956b04813133ba909b",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><p>图片拖一拖，上传加压缩\nDemo网站：<a href=\"http://upload.andylistudio.com\">http://upload.andylistudio.com</a>\n源码地址：<a href=\"https://github.com/Andyliwr/ldk-upload-img\">https://github.com/Andyliwr/ldk-upload-img</a>\n截图：\n<img src=\"http://fs.andylistudio.com/source/img/slide1.png\" alt></p>\n<p><img src=\"http://fs.andylistudio.com/source/img/slide2.png\" alt></p>\n<p><img src=\"http://fs.andylistudio.com/source/img/slide3.png\" alt></p>\n</div>",
        "title": "基于koa2实现的图片上传工具",
        "last_reply_at": "2017-11-13T02:57:36.521Z",
        "good": false,
        "top": false,
        "reply_count": 0,
        "visit_count": 105,
        "create_at": "2017-11-13T02:57:36.521Z",
        "author": {
            "loginname": "Andyliwr",
            "avatar_url": "https://avatars1.githubusercontent.com/u/12456160?v=4&s=120"
        }
    }, {
        "id": "5a09075ba57c17282e120616",
        "author_id": "59e873510c2567c066a991ee",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><p>4.4.2 新增功能</p>\n<p>1、添加了测试轮询短信发送的功能</p>\n<p>2、新版支持环境变量 可以用{{var}} 和 env[var]来引用</p>\n<p>源码地址： <a href=\"https://github.com/sx1989827/DOClever/releases\">https://github.com/sx1989827/DOClever/releases</a></p>\n<p>官网地址:<a href=\"http://www.doclever.cn\">http://www.doclever.cn</a></p>\n<p>产品功能：</p>\n<p>1.可以对接口信息进行编辑管理，支持 get,post,put,delete,patch 五种方法，支持 https 和 https 协议，并且支持 query，body，json，raw，rest，formdata 的参数可视化编辑。同时对 json 可以进行无限层次可视化编辑。并且，状态码，代码注入，markdown 文档等附加功能应有尽有。</p>\n<p>2.接口调试运行，一个都不能少，可以对参数进行加密，从 md5 到 aes 一应俱全，返回参数与模型实时分析对比，给出不一致的地方，找出接口可能出现的问题。如果你不想手写文档，那么试试接口的数据生成功能，可以对接口运行的数据一键生成文档信息。</p>\n<p>3.mock 的无缝整合，DOClever 自己就是一个 mock 服务器，当你把接口的开发状态设置成已完成，本地 mock 便会自动请求真实接口数据，否则返回事先定义好的 mock 数据。</p>\n<p>4.支持 postman，rap，swagger 的导入，方便你做无缝迁移，同时也支持 html 文件的导出，方便你离线浏览！</p>\n<p>5.项目版本和接口快照功能并行，你可以为一个项目定义 1.0，1.1，1.2 版本，并且可以自由的在不同版本间切换回滚，再也不怕接口信息的遗失，同时接口也有快照功能，当你接口开发到一半或者接口需求变更的时候，可以随时查看之前编辑的接口信息。</p>\n<p>6.自动化测试功能，目前市面上类似平台的接口自动化测试大部分都是伪自动化，对于一个复杂的场景，比如获取验证码，登陆，获取订单列表，获取某个特定订单详情这样一个上下文关联的一系列操作无能为力。而 DOClever 独创的自动化测试功能，只需要你编写极少量的 javascript 代码便可以在网页里完成这样一系列操作，同时，DOClever 还提供了后台定时批量执行测试用例并把结果发送到团队成员邮箱的功能，你可以及时获取接口的运行状态。</p>\n<p>7.团队协作功能，很多类似的平台这样的功能是收费的，但是 DOClever 觉得好东西需要共享出来，你可以新建一个团队，并且把团队内的成员都拉进来，给他们分组，给他们分配相关的项目以及权限，发布团队公告等等。</p>\n<p>8.DOClever 开源免费，支持内网部署，很多公司考虑到数据的安全性，不愿意把接口放到公网上，没有关系，DOClever 给出一个方便快捷的解决方案，你可以把平台放到自己的内网上，完全不需要连接外网，同时功能一样也不少，即便是对于产品的升级，DOClever 也提供了很便捷的升级方案！</p>\n</div>",
        "title": "接口管理平台 DOClever 4.2.2 版本更新,免费开源 支持线下部署 新版支持环境变量",
        "last_reply_at": "2017-11-13T02:45:47.409Z",
        "good": false,
        "top": false,
        "reply_count": 0,
        "visit_count": 70,
        "create_at": "2017-11-13T02:45:47.409Z",
        "author": {
            "loginname": "qswl",
            "avatar_url": "https://avatars0.githubusercontent.com/u/26077298?v=4&s=120"
        }
    }, {
        "id": "5a0520d7ee9b35da75a869fe",
        "author_id": "56ce68bc842c03521a73520e",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p>需要对各种业务做多个层面的复杂统计，请教一下大家的经验。</p>\n</div>",
        "title": "请教如何设计有各种统计需求的数据库？",
        "last_reply_at": "2017-11-13T02:29:46.668Z",
        "good": false,
        "top": false,
        "reply_count": 4,
        "visit_count": 205,
        "create_at": "2017-11-10T03:45:27.100Z",
        "author": {
            "loginname": "qujinxiong",
            "avatar_url": "https://avatars1.githubusercontent.com/u/15104950?v=4&s=120"
        }
    }, {
        "id": "59eeb05af8d374775c0157d0",
        "author_id": "59e4a9e9bcfcc03162f2fed4",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p>找大佬指点~~~~~</p>\n</div>",
        "title": "网页当中的分享到QQ，微信，是怎么做的？",
        "last_reply_at": "2017-11-13T01:38:35.978Z",
        "good": false,
        "top": false,
        "reply_count": 13,
        "visit_count": 1177,
        "create_at": "2017-10-24T03:15:38.770Z",
        "author": {
            "loginname": "wwdDongDong",
            "avatar_url": "https://avatars1.githubusercontent.com/u/30905492?v=4&s=120"
        }
    }, {
        "id": "5a08444763329eb474b0c2ce",
        "author_id": "56ac4d7f26d02fc6626bb3b1",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p>最近打算研究下源码，想问下源码怎么调试呢？</p>\n</div>",
        "title": "nodejs源码怎么调试？",
        "last_reply_at": "2017-11-13T01:11:35.652Z",
        "good": false,
        "top": false,
        "reply_count": 1,
        "visit_count": 159,
        "create_at": "2017-11-12T12:53:27.584Z",
        "author": {
            "loginname": "oyosc",
            "avatar_url": "https://avatars1.githubusercontent.com/u/13896491?v=4&s=120"
        }
    }, {
        "id": "59269648d371b6372a8afda3",
        "author_id": "591cfd493504ce1c2ac45da7",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><p>第一次社区发帖，破个处~</p>\n<p>因为之前项目，线上因为超预期的用户量导致服务器cpu爆满，然后大家都懂的~\n今天恰好看到一篇node的事件队列的文章，作者大力推荐kue，说是基于redis的pub/sub… 于是开了个test，\n废话不说，直接干~</p>\n<p>既然是事件队列，如果单进程内测试多没意思，下面代码使用node的cluster模块创建4个子进程作为 kue的工作进程，然后在master内创建任务</p>\n<pre class=\"prettyprint\"><code>&#x27;use strict&#x27;;\n\nconst kue = require(&#x27;kue&#x27;);\nconst cluster = require(&#x27;cluster&#x27;);\nconst logger = require(&#x27;log4js&#x27;).getLogger(&quot;default&quot;);\n\nconst queues = kue.createQueue();\n\nfunction createJob() {\n\tlet job = queues.create(&quot;email&quot;, {\n\t\tname: [&quot;jason&quot;, &quot;kitty&quot;, &quot;jion&quot;, &quot;mali&quot;][Math.random() * 4 | 0]\n\t}).save();\n\tlogger.debug(&quot;create job [%s] from master[%d]&quot;, job.data.name, process.pid);\n\tsetTimeout(createJob, Math.random() * 10000);\n}\n\nif (cluster.isMaster) {\n\n\tlogger.debug(&quot;master %s running!&quot;, process.pid);\n\n\tfor (let i = 0; i &lt; 4; i++) {\n\t\tcluster.fork();\n\t}\n\tcreateJob();\n\tcluster.on(&#x27;exit&#x27;, function (worker, code) {\n\t\tlogger.debug(&quot;worker %s is died by %s&quot;, worker.process.pid, code);\n\t});\n} else {\n\tqueues.process(&#x27;email&#x27;, (job, done)=&gt; {\n\t\tlogger.debug(&quot;worker %s process mail job[%d][%s]&quot;, process.pid, job.id, job.data.name);\n\t\tsetTimeout(done, Math.random() * 20000);\n\t});\n}\n</code></pre><p>说明下 上面栗子 需要启动本机的redis 6379端口，另外需要一个log4js的模块（或者替换console输出）\n执行输出：\n\t[2017-05-25 16:11:31.937] [DEBUG] default - master 52761 running!\n\t[2017-05-25 16:11:31.950] [DEBUG] default - create job [mali] from master[52761]\n\t[2017-05-25 16:11:32.134] [DEBUG] default - worker 52763 process mail job[72][mali]\n\t[2017-05-25 16:11:38.802] [DEBUG] default - create job [jion] from master[52761]\n\t[2017-05-25 16:11:38.812] [DEBUG] default - worker 52764 process mail job[73][jion]\n\t[2017-05-25 16:11:47.315] [DEBUG] default - create job [kitty] from master[52761]\n\t[2017-05-25 16:11:47.324] [DEBUG] default - worker 52766 process mail job[74][kitty]\n\t[2017-05-25 16:11:49.151] [DEBUG] default - create job [jion] from master[52761]\n\t[2017-05-25 16:11:49.159] [DEBUG] default - worker 52765 process mail job[75][jion]\n\t[2017-05-25 16:11:53.356] [DEBUG] default - create job [jason] from master[52761]\n\t[2017-05-25 16:11:53.361] [DEBUG] default - worker 52763 process mail job[76][jason]\n\t[2017-05-25 16:12:00.009] [DEBUG] default - create job [jason] from master[52761]\n\t[2017-05-25 16:12:00.018] [DEBUG] default - worker 52766 process mail job[77][jason]\n\t[2017-05-25 16:12:07.785] [DEBUG] default - create job [mali] from master[52761]\n\t[2017-05-25 16:12:07.789] [DEBUG] default - worker 52764 process mail job[78][mali]\n\t[2017-05-25 16:12:11.305] [DEBUG] default - create job [kitty] from master[52761]\n\t[2017-05-25 16:12:11.309] [DEBUG] default - worker 52763 process mail job[79][kitty]</p>\n<p>最后在大概描述下个人理解的作用！\n首先可以作为用户消息入口，输出到逻辑代码，这样用户的请求指令会被缓存到redis内，不会因为逻辑执行压力而在导致node内存暴涨崩溃~\n接上面说，可以扩展，接口和逻辑分离。\n今天是第一次测试，看kue官方文档，支持事件优先等级和失败重试等，貌似非常强大！。\n最后奉上github地址：<a href=\"https://github.com/Automattic/kue\">https://github.com/Automattic/kue</a></p>\n</div>",
        "title": "Node.js Kue多进程事件队列用例",
        "last_reply_at": "2017-11-12T12:53:22.404Z",
        "good": false,
        "top": false,
        "reply_count": 4,
        "visit_count": 1326,
        "create_at": "2017-05-25T08:31:04.251Z",
        "author": {
            "loginname": "Goofo",
            "avatar_url": "https://avatars1.githubusercontent.com/u/26354901?v=4&s=120"
        }
    }, {
        "id": "5a07ecd4a57c17282e1205fe",
        "author_id": "556dbe07bf871b3962efb861",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p>好久不见，想死大家了，最近大家都在研究些什么呢，来聊一聊呗～</p>\n</div>",
        "title": "最近大家都在研究些什么技术呢～",
        "last_reply_at": "2017-11-12T11:07:19.974Z",
        "good": false,
        "top": false,
        "reply_count": 2,
        "visit_count": 342,
        "create_at": "2017-11-12T06:40:20.720Z",
        "author": {
            "loginname": "jaylinWang",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4530355?v=4&s=120"
        }
    }, {
        "id": "5a081077a57c17282e120608",
        "author_id": "59e9a3f3a9a1e19f3634c941",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><p>（node+express+ejs模板）做项目权限控制的时候遇到了这么一个情景。项目的需求是点击一级菜单默认显示该一级菜单的第一个子菜单的页面。 当某个账号拥有一级菜单的权限，而没有该一级菜单的第一个字菜单权限的时候默认显示第二个子菜单页面，如此类推。我为每个菜单都写一个路由，没做权限控制的时候，一级菜单和该一级菜单共用一个路由。现在要做权限，那么就必须为一级菜单单独写一个路由。在这个路由里根据权限来决定显示哪个子菜单页面。这样就会有一个路由跳转路由的问题。于是我就用res.redirect 进行重定向。但老是报404错误，纠结了好久还是没能找出为啥重定向就不行。无意中看到req有一个url的属性。于是就改变req.url的值实现，路由跳转。这个是一篇没有技术含量的文章，记录下来就是为了方便自己学习。如果有哪个大大知道为啥res.redirect 重定向 会报错希望不吝赐教。整个项目都没有html文件，只有ejs模板 ，我重定向是定向另外一个路由。</p>\n</div>",
        "title": "node.js 跳转路由。",
        "last_reply_at": "2017-11-12T09:12:23.519Z",
        "good": false,
        "top": false,
        "reply_count": 0,
        "visit_count": 146,
        "create_at": "2017-11-12T09:12:23.519Z",
        "author": {
            "loginname": "InfaceMan",
            "avatar_url": "https://avatars3.githubusercontent.com/u/32891469?v=4&s=120"
        }
    }, {
        "id": "5a0801e1001f0eb571c1b02d",
        "author_id": "593d51ee8ce045ee166a1417",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p>现在网上的教程全是2017年以前的，全部都不能用了，今天突然好奇想写个抓取点赞和阅读数的爬虫（比获取文章内容难多了），\n我的操作如下：\n首先使用 <strong>charles</strong>进行网络请求分析，成功得到文章的数据接口如下：\n\t\t<img src=\"//dn-cnode.qbox.me/FjPrgYHaZKCTyr-bzlVr0ZBPg0mD\" alt=\"1.png\"></p>\n<p>这里就是 点赞和阅读数，再仔细看看他的请求参数\n<strong>1.query 参数</strong>\n<img src=\"//dn-cnode.qbox.me/FrSOoQTXJ_q0YAFuukIg5gGDyFNy\" alt=\"2.png\"></p>\n<p><strong>2.form参数</strong>\n<img src=\"//dn-cnode.qbox.me/FumQTPsnFIBC2cr_Zyil9U-eEPtF\" alt=\"3.png\"></p>\n<p><strong>3.headers</strong>\n<img src=\"//dn-cnode.qbox.me/FlaSmJIr15R35-dCeQ0pDbmw1w2N\" alt=\"4.png\"></p>\n<p>**接下来使用 **postman <strong>进行模拟请求</strong>\n参数如下：\n<img src=\"//dn-cnode.qbox.me/Fg1K3KzyUClPVdhJOrUsSxBCfXea\" alt=\"5.png\">\n<img src=\"//dn-cnode.qbox.me/FpsJ2YHggppn0DhK9Gln7UI-cry7\" alt=\"6.png\"></p>\n<p>很遗憾结果如下：\n<img src=\"//dn-cnode.qbox.me/Fn9A7RGnbJ8auUCUdf8Yh7Gxp7fq\" alt=\"7.png\"></p>\n<p>我有点不明白 网络请求的参数全部都是一样的，为什么请求不到呢。。我也写过类似的nodejs中间价，但是当cookie 和 Host , Referer 都对的时候 按理就应该放行的呀。。。不明白 哪里有问，很好奇 请指教，多谢了</p>\n</div>",
        "title": "如何获取微信公众号文章的阅读和点赞数",
        "last_reply_at": "2017-11-12T08:59:40.837Z",
        "good": false,
        "top": false,
        "reply_count": 3,
        "visit_count": 144,
        "create_at": "2017-11-12T08:10:09.999Z",
        "author": {
            "loginname": "lpbird",
            "avatar_url": "https://avatars1.githubusercontent.com/u/26104624?v=4&s=120"
        }
    }, {
        "id": "59dca3a261932717683d21fc",
        "author_id": "593d51ee8ce045ee166a1417",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><p>仿coco点餐系统的微信小程序 （后台部分本来用的egg.js,为了能让大家下载之后直接跑起来 就换成了easymock） 仅供交流学习使用,使用之前微信小程序调试工具前要设置不进行域名验证 （欢迎大家指教qq：3471633742）下面是6张效果图，可以下载下来跑跑  github地址:<img src=\"https://github.com/lpbird/imitate-coco-xcx\" alt=\"git地址\"><a href=\"https://github.com/lpbird/imitate-coco-xcx\">https://github.com/lpbird/imitate-coco-xcx</a><img src=\"//dn-cnode.qbox.me/Fk76a0jhwlqx67iAWKmwkdA6uXKP\" alt=\"1.png\"><img src=\"//dn-cnode.qbox.me/FrfzK8OK-7eCaE9u3QKyXIEpg4C0\" alt=\"2.png\"><img src=\"//dn-cnode.qbox.me/FrzNcaUjseUxZaUiQyZGzKQ-pNtv\" alt=\"3.png\"><img src=\"//dn-cnode.qbox.me/FlfpaptaXosZ4gPUjvr8SnqeLlPN\" alt=\"4.png\"><img src=\"//dn-cnode.qbox.me/Fg9hyi6Nj3Q6x5sL65szU7bp8zii\" alt=\"5.png\"><img src=\"//dn-cnode.qbox.me/FiRna-k2sWvlAwjP_jKstH7avhOQ\" alt=\"6.png\"></p>\n</div>",
        "title": "分享微信小程序干货：模仿coco的微信点餐系统",
        "last_reply_at": "2017-11-12T07:43:08.791Z",
        "good": false,
        "top": false,
        "reply_count": 8,
        "visit_count": 1226,
        "create_at": "2017-10-10T10:40:34.976Z",
        "author": {
            "loginname": "lpbird",
            "avatar_url": "https://avatars1.githubusercontent.com/u/26104624?v=4&s=120"
        }
    }, {
        "id": "5a0570c588c853c52fd56838",
        "author_id": "58b1510b7872ea0864fee0ce",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p>123123</p>\n</div>",
        "title": "13213212131",
        "last_reply_at": "2017-11-12T07:42:09.108Z",
        "good": false,
        "top": false,
        "reply_count": 1,
        "visit_count": 155,
        "create_at": "2017-11-10T09:26:29.852Z",
        "author": {
            "loginname": "xxxxxMiss",
            "avatar_url": "https://avatars0.githubusercontent.com/u/17688047?v=4&s=120"
        }
    }, {
        "id": "59c21044b53b601512be4283",
        "author_id": "59c200498812ce51127a9031",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"></div>",
        "title": "免费可以测试的vps服务器资源？",
        "last_reply_at": "2017-11-12T07:33:28.286Z",
        "good": false,
        "top": false,
        "reply_count": 20,
        "visit_count": 1873,
        "create_at": "2017-09-20T06:52:52.852Z",
        "author": {
            "loginname": "xiaodu2017",
            "avatar_url": "https://avatars1.githubusercontent.com/u/31922823?v=4&s=120"
        }
    }, {
        "id": "5a06c3c842df5ebf48fa9320",
        "author_id": "57e330bcc4ae8ff239776e33",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p>node做金融管理软件合适吗？数据库用mongodb问题大不大，是不是一定要用oracle</p>\n<p>来自酷炫的 <a href=\"https://github.com/TakWolf/CNode-Material-Design\">CNodeMD</a></p>\n</div>",
        "title": "node做金融管理软件合适吗？数据库用mongodb问题大不大",
        "last_reply_at": "2017-11-12T07:21:17.018Z",
        "good": false,
        "top": false,
        "reply_count": 13,
        "visit_count": 292,
        "create_at": "2017-11-11T09:32:56.270Z",
        "author": {
            "loginname": "rianran1993",
            "avatar_url": "https://avatars1.githubusercontent.com/u/22359049?v=3&s=120"
        }
    }]
}

